;+
; on daily bases, preprocess efield for certain probe.
; subtract background E field near earth (<3 Re)
; remove bad E field when Eu and Ev do not match and
; when they are asymetric around 0.
; 
; calc E GSE from V, save the quaternion of rotation matrix uvw2gse, 
; from which wsc_gse can be extracted.
;-


pro rbsp_preprocess_efield, ut0, probes = tprobe, no_spice_load = no_spice_load

;---Constant.
    secofday = 86400d
    dr0 = 1d/16     ; data rate, 16 Hz.
    spinrate = 11   ; sec, 10.9378 sec.
    blen0s = [100d,100,12]  ; m, twice of boom lengths.
    fshrts = [1d,1,1]       ; use 1 temperarily.
    blen1s = blen0s*fshrts
    maxerng = 400d
    minerng = 5d

    deg = 180d/!dpi
    rad = !dpi/180
    re = 6378d & re1 = 1d/re


;---Settings.
    if n_elements(tprobe) eq 0 then tprobe = 'a'
    pre0 = 'rbsp'+tprobe+'_'

    rootdir = shomedir()+'/rbsp_efield_preprocess'
    if file_test(rootdir,/directory) eq 0 then file_mkdir, rootdir
    
    utr = ut0-(ut0 mod secofday)+[0,secofday]
    ut2016 = time_double('2015-10-01')
    date = time_string(utr[0],tformat='YYYY_MMDD')        
    
    
    rgb = [6,4,2]
    xyz = ['x','y','z']
    uvw = ['u','v','w']

    erng = 200d ; E range for plotting.

    device, decomposed = 0
    loadct2, 43

    tplot_options, 'version', 2
    tplot_options, 'num_lab_min', 10
    tplot_options, 'labflag', -1
    tplot_options, 'xticklen', -0.03
    tplot_options, 'yticklen', -0.005
    tplot_options, 'constant', 0
    tplot_options, 'xmargin', [18,10]
    
;goto, startplot

    
;---load position.
; rbspx_[pos_gse,mlt,lshell,dis]
    
    if no_spice_load eq 0 then $
        rbsp_load_spice_kernels, trange = utr, probes = tprobe

    tuts = smkarthm(utr[0],utr[1],60,'dx')
    rbsp_load_spice_state, probe=tprobe, coord='gse', times=tuts, /no_spice_load
    if no_spice_load eq 0 then rbsp_load_spice_kernels, trange=utr, probes=tprobe, /unload
        
    tvar = pre0+'pos_gse'
    get_data, pre0+'state_pos_gse', tmp, posgse
    posgse = posgse*re1
    tdat = posgse
    store_data, pre0+'state_*', /delete
    store_data, tvar, tuts, tdat, limits={ytitle:'(Re)', colors:rgb, labels:'GSE '+xyz}

                
    tvar = pre0+'mlt'
    tdat = atan(posgse[*,1],posgse[*,0])*deg
    tdat = (tdat+360) mod 360   ; convert to 0-360, or 0-24 hr.
    tdat = (tdat/15 + 12) mod 24
    store_data, tvar, tuts, tdat, limits={ytitle:'(hr)',labels:'MLT'}
        
        
    tvar = pre0+'lshell'
    possm = sgse2sm(posgse, stoepoch(tuts,'unix'))
    mlat = atan(possm[*,2],sqrt(possm[*,0]^2+possm[*,1]^2)) ; in rad.
    dis = sqrt(possm[*,0]^2+possm[*,1]^2+possm[*,2]^2)
    tdat = dis/(cos(mlat)^2)
    store_data, tvar, tuts, tdat, limits={ytitle:'(Re)',labels:'L-shell'}
        
    store_data, pre0+'mlat', tuts, mlat*deg, limits = {ytitle:'MLat (deg)'}
    store_data, pre0+'dis', tuts, dis, limits = {ytitle:'Dist (Re)'}


    
;---load vsvy and calc esvy (instead of load esvy).
; rbspx_[vsc,vsvy]
    
    tvar = pre0+'vsc'    
    dat = sread_rbsp_efw_l2(utr, probes=tprobe, type='vsvy')
    if size(dat,/type) ne 8 then begin
        message, 'no V data ...', /continue
        return
    endif
    
    uts = sfmepoch(dat.epoch, 'unix')
    nrec = n_elements(uts)
    vsvy = dat.vsvy
    ; calibrate vsvy, tried rbsp_efw_get_cal_params, but really no effect
    ; since offset is 0, gain is not used.  
    ; end up using V12, may consider more complex ways.
    vsc = mean(vsvy[*,0:1], dimension = 2)
    if utr[0] gt ut2016 then vsc = mean(vsvy[*,2:3], dimension = 2)
    store_data, tvar, uts, vsc, limits = {ytitle:'(V)', labels:'Vsc'}
    store_data, pre0+'vsvy', uts, vsvy[*,0:3], limits = $
        {ytitle:'(V)', colors:[1,2,3,4], labels:'V'+['1','2','3','4']}
    
    
    ; calc E uvw.
    ; rbspx_euvw

    tvar = pre0+'euvw'    
    ; the following is based on linear regression on v1,v2 and eu, v3,v4 and ev.
    eu = (vsvy[*,0]-vsvy[*,1])/blen1s[0]*1e3   ; V -> V/m -> mV/m.
    ev = (vsvy[*,2]-vsvy[*,3])/blen1s[1]*1e3
    ew = (vsvy[*,4]-vsvy[*,5])/blen1s[2]*1e3
    ew[*] = 0
    ; remove dc-offset.
    nspin = 2
    tnrec = nspin*spinrate/dr0
    eu = eu-smooth(eu, tnrec, /edge_truncate, /nan)
    ev = ev-smooth(ev, tnrec, /edge_truncate, /nan)
    store_data, tvar, uts, [[eu],[ev],[ew]], limits = $
        {ytitle:'(mV/m)', labels:'E'+uvw, colors:rgb, yrange:[-1,1]*erng}
    tvar = pre0+'esvy'  ; this will be further modified.
    store_data, tvar, uts, [[eu],[ev],[ew]], limits = $
        {ytitle:'(mV/m)', labels:'E'+uvw, colors:rgb}


    ; coefficient to remove E field near earth (< 3 Re).
    ; rbspx_[e0,coef_e0].

    ; make a decaying window.
    mindis0 = 3 ; Re.
    get_data, pre0+'dis', tuts, dis
    dis = interpol(dis, tuts, uts)
    win0 = double(dis le mindis0)
    winwd = 9600/dr0
    winedge = exp(-findgen(winwd)/winwd*5)
    idx = where(win0-shift(win0,1) eq 1, cnt)   ; left edge.
    for i = 0, cnt-1 do begin
        j0 = idx[i]
        dj = (winwd-1)<(j0-0)
        win0[j0-dj:j0] = reverse(winedge[0:dj])
    endfor
    
    idx = where(win0-shift(win0,-1) eq 1, cnt)   ; right edge.
    for i = 0, cnt-1 do begin
        j0 = idx[i]
        dj = (winwd-1)<(nrec-1-j0)
        win0[j0:j0+dj] = (winedge[0:dj])
    endfor
    
    emag = sqrt(eu^2+ev^2+ew^2)
    emagbg = dblarr(nrec)
    drec = (dis-mindis0)/(max(dis)-mindis0)>0
    drec = (drec^0.4*100+1)*spinrate/dr0*0.5
    for i = 0, nrec-1 do begin
        ti = i
        i1 = (ti-drec[i])>0
        i2 = (ti+drec[i])<nrec-1
        emagbg[ti] = min(emag[i1:i2])
    endfor
    ec = (1-emagbg/emag)
    store_data, pre0+'coef_e0', uts, ec
    store_data, pre0+'e0', uts, emagbg, limits = {ytitle:'|E| BG!C(mV/m)'}
    
    ; apply the coefficient to E field.
    tvar = pre0+'esvy'
    get_data, tvar, tuts, esvy
    for i=0, 1 do esvy[*,i] *= ec
    store_data, tvar, tuts, esvy
    eu = esvy[*,0]
    ev = esvy[*,1]
    
        

;---Make flags to tell bad E field.
    
    ; get the upper and lower envelope for several spins.
    dspin = 5d  ; 5 spins.
    drec = dspin*spinrate/dr0
    perc = 0.95
    padt = 300d ; sec.

    tdat = eu
    fmin = dblarr(nrec)
    fmax = dblarr(nrec)
    for i=0, nrec-1, drec do begin
        ti = i
        i1 = (ti-drec)>0
        i2 = (ti+drec)<(nrec-1)
        f0s = tdat[i1:i2]
        tnrec = n_elements(f0s)
        f1s = abs(f0s)
        vmax = f1s[sort(f1s)] & vmax = vmax[tnrec*perc]
        f2s = f0s & f2s[where(f1s ge vmax)] = !values.d_nan
        fmin[i1:i2] = min(f2s,/nan)
        fmax[i1:i2] = max(f2s,/nan)
    endfor
    umin = fmin
    umax = fmax
    
    tdat = ev
    fmin = dblarr(nrec)
    fmax = dblarr(nrec)
    for i=0, nrec-1, drec do begin
        ti = i
        i1 = (ti-drec)>0
        i2 = (ti+drec)<(nrec-1)
        f0s = tdat[i1:i2]
        tnrec = n_elements(f0s)
        f1s = abs(f0s)
        vmax = f1s[sort(f1s)] & vmax = vmax[tnrec*perc]
        f2s = f0s & f2s[where(f1s ge vmax)] = !values.d_nan
        fmin[i1:i2] = min(f2s,/nan)
        fmax[i1:i2] = max(f2s,/nan)
    endfor
    vmin = fmin
    vmax = fmax
    
    store_data, pre0+'euv_env', uts, [[umin],[umax],[vmin],[vmax]], limits=$
        {colors:[6,6,4,4], labels:['Eu','','Ev',''], ytitle:'(mV/m)'}


    ; use the envelope to locate bad E field.
    dmax = smooth(umax-vmax,padt/dr0,/nan)
    dmin = smooth(umin-vmin,padt/dr0,/nan)
    idx = where(finite(dmax,/nan), cnt) & if cnt ne 0 then dmax[idx] = 1e30
    idx = where(finite(dmin,/nan), cnt) & if cnt ne 0 then dmin[idx] = 1e30
    
    flags = (abs(dmax) ge 5) or (abs(dmin) ge 5)
    store_data, pre0+'flag_euv', uts, flags


    ; check eclipse time.
    tmp = sread_rbsp_eclipse_time(utr, probes = tprobe)
    flags = interpol(double(tmp.flags),tmp.uts,uts)
    idx = where(flags ne 0, cnt)
    if cnt ne 0 then flags[idx] = 1
    store_data, pre0+'flag_eclipse', uts, flags, limits = $
        {ytitle:'', yrange:[-0.5,1.5], yticks:1, yminor:0, ystyle:1, $
        labels:['1:eclipse']}
        
    ; check sdt time.
    tmp = sread_rbsp_efw_sdt_time(utr[0], probes = tprobe)
    flags = interpol(double(tmp.flags),tmp.uts,uts)
    idx = where(flags ne 0, cnt)
    if cnt ne 0 then flags[idx] = 1
    store_data, pre0+'flag_sdt', uts, flags, limits = $
        {ytitle:'', yrange:[-0.5,1.5], yticks:1, yminor:0, ystyle:1, $
        labels:['1:sdt']}
    

    ; combine flags.
    vars = pre0+'flag_'+['euv','eclipse','sdt']
    flags = bytarr(nrec)
    foreach tvar, vars do begin
        get_data, tvar, uts, dat
        flags = flags or dat
    endforeach

    idx = where(flags eq 1, cnt)
    drec = padt/dr0
    if cnt ne 0 then begin
        for i=0, cnt-1 do flags[(idx[i]-drec)>0:(idx[i]+drec)<(nrec-1)] = 1
        idx = where(flags eq 1)
        tvar = pre0+'esvy'
        get_data, tvar, tuts, esvy
        esvy[idx,*] = !values.d_nan
        store_data, tvar, uts, esvy
    endif
    store_data, pre0+'bade_flag', uts, flags, limits=$
        {labels:'1: bad E', yrange:[-0.5,1.5], ystyle:1, yticks:1, ytickv:[0,1], panel_size:0.4, ytitle:''}
        
    


    ;---test!!! correct for boom shorting (in relative sense, need an overall factor).
        nsec = 10
        bsu = (umax-umin)*0.5
        bsv = (vmax-vmin)*0.5
        tmp = (bsu+bsv)*0.5
        bsu = tmp/bsu & bsu[idx] = 1d
        bsv = tmp/bsv & bsv[idx] = 1d
        bsu = scalcbg(bsu, nsection=nsec)
        bsv = scalcbg(bsv, nsection=nsec)
        
        eu *= bsu
        ev *= bsv
        store_data, pre0+'bs', uts, [[bsu],[bsv]], limits=$
            {labels:['u','v'], colors:[6,4]}
        get_data, pre0+'esvy', uts, esvy
        esvy[*,0] *= bsu
        esvy[*,1] *= bsv
        store_data, pre0+'esvy', uts, esvy
        
                
        vars = pre0+['vsvy','euv_mag','euv_mag_diff_abs','euv_avg','e0']
        store_data, vars, /delete
        
        idx = where(flags eq 1, cnt)
        if cnt ne 0 then begin
            eu[idx] = !values.d_nan
            ev[idx] = !values.d_nan
        endif
        
        
    ;---rotate uvw into mgse.
        ; calc epoch times for spice (different than the epoch in cdfs).
        tuts = smkarthm(utr[0], utr[1], 1, 'dx')
        tmp = time_string(tuts[0],tformat='YYYY-MM-DDThh:mm:ss.ffffff')
        cspice_str2et, tmp, tet0
        tets = tet0+tuts-tuts[0]
    
        scid = strupcase(pre0+'science')
        cspice_pxform, scid, 'GSE', tets, muvw2gse
        quvw2gse = mtoq(transpose(muvw2gse))
        store_data, pre0+'q_uvw2gse', tuts, quvw2gse
        quvw2gse = qslerp(quvw2gse, tuts, uts)
        if n_elements(quvw2gse) eq 1 and quvw2gse[0] eq -1 then begin
            ; failed to use quternion, use the dumb way.
            ; this means manauver?
            tfn = shomedir()+'/maybe_manauver.dat'
            openw, lun, tfn, /get_lun, /append
            printf, lun, 'RBSP-'+strupcase(tprobe)+': '+ $
                time_string(uts[0],tformat='YYYY-MM-DD')
            free_lun, lun
            tmp = time_string(uts[0],tformat='YYYY-MM-DDThh:mm:ss.ffffff')
            cspice_str2et, tmp, tet0
            ets = tet0+uts-uts[0]
            cspice_pxform, scid, 'GSE', ets, muvw2gse
            quvw2gse = mtoq(transpose(muvw2gse))
            store_data, pre0+'q_uvw2gse', tuts, quvw2gse
        endif else muvw2gse = transpose(qtom(quvw2gse))
        
        ex = eu*muvw2gse[0,0,*] + ev*muvw2gse[1,0,*] + ew*muvw2gse[2,0,*]
        ey = eu*muvw2gse[0,1,*] + ev*muvw2gse[1,1,*] + ew*muvw2gse[2,1,*]
        ez = eu*muvw2gse[0,2,*] + ev*muvw2gse[1,2,*] + ew*muvw2gse[2,2,*]
        
        tvar = pre0+'egse'
        store_data, tvar, uts, [[ex],[ey],[ez]], limits = $
            {ytitle:'(mV/m)', colors:[6,4,2], labels:'GSE E'+['x','y','z']}
        
        
        
        
;---Plot to show the correction for boom shorting.
;        ofn = shomedir()+'/rbsp_spin_tone_corrected.pdf'
;        ofn = shomedir()+'/rbsp_spin_tone_original.pdf'
;        sgopen, ofn, xsize=15, ysize=5, /inch
;        device, decomposed=0
;        loadct2, 43
;        
;        tplot_options, 'xmargin', [16,10]
;        ylim, pre0+['egse','euvw','esvy','euv_env'], [-1,1]*0.8
;        
;        vars = pre0+['egse','euvw','euv_env','esvy']
;        flabs = ['a. E GSE', 'b. Original!C    Euv', 'c. Euv!C    envelope', 'd. Corrected!C    Euv']
;        tutr = time_double(['2013-11-27/00:40','2013-11-27/00:45'])
;        tplot, vars, trange=tutr, figlabel=flabs
;        sgclose
        


;---Plot to show: remove bad E, co-rotation E.
        xsz = 11
        ysz = 8.5
        

        tdir = rootdir+'/rbsp'+tprobe+'/'+time_string(ut0,tformat='YYYY')
        if file_test(tdir,/directory) eq 0 then file_mkdir, tdir
        ofn = tdir+'/'+date+'_rbsp'+tprobe+'_preprocess_field.pdf'
;ofn = 0
        
        sgopen, ofn, xsize = xsz, ysize = ysz, /inch
        
        device, decomposed = 0
        loadct2, 43
        
        xchsz = double(!d.x_ch_size)/!d.x_size
        ychsz = double(!d.y_ch_size)/!d.y_size


        titl = 'RBSP-'+strupcase(tprobe)+' '+time_string(utr[0],tformat='YYYY-MM-DD')+' E field preprocess: remove co-rotation E, bad E'        
        
        vars = pre0+['euv_env','bade_flag','euvw'+uvw[0:1],'egse'+xyz]
        flabs = ['a','b','c','d','e','f','g']+'. '+$
            ['|Euv|','Flag','Eu','Ev','GSE E'+xyz]
        
        
        tvar = pre0+'euvw'
        stplot_split, tvar, newnames=tvar+uvw, colors=rgb
        tvar = pre0+'egse'
        stplot_split, tvar, newnames=tvar+xyz, colors=rgb
        
        get_data, pre0+'euvw', uts, dat
        erng = max(abs(dat),/nan)
        erng = ceil(erng/10)*10
        erng = erng<maxerng
        tvar = pre0+['euv_env','euvw'+uvw] 
        options, tvar, 'yrange', [-1,1]*erng
        options, tvar, 'ystyle', 1
        options, tvar, 'yticks', 4
        options, tvar, 'yminor', 5
        
        tvar = pre0+'egse'
        get_data, tvar, uts, dat
        erng = max(abs(dat),/nan)
        erng = ceil(erng/10)*10
        erng = erng>minerng
        
        tvar = tvar+xyz
        options, tvar, 'yrange', [-1,1]*erng
        options, tvar, 'ystyle', 1
        options, tvar, 'yticks', 4
        options, tvar, 'yminor', 5
        
         
        tplot, vars, trange=utr, figlabel=flabs, get_plot_position=poss
        xyouts, (poss[0,0]+poss[2,0])*0.5, poss[3,0]+ychsz*0.8, /normal, alignment=0.5, titl, charsize=1.2

        idx = where(vars eq pre0+'bade_flag')
        tpos = reform(poss[*,idx])
        plot, utr, [-0.5,1.5], /nodata, /noerase, position=tpos, $
            xstyle=5, ystyle=5
        vars = pre0+'flag_'+['euv','eclipse','sdt']
        foreach tvar, vars, i do begin
            get_data, tvar, uts, dat
            plots, uts, (dat<(1-(i+1)*0.1)), color=rgb[i]
        endforeach
        
        tvar = pre0+['euvw'+uvw,'egse'+xyz]
        store_data, tvar, /delete

        sgclose
    
end

probes = ['a','b']
utr0 = time_double(['2012-09-25','2016-12-31'])
utr0 = time_double(['2014-09-25','2014-09-26'])
;utr0 = time_double(['2012-11-14','2012-11-15']) 
;utr0 = time_double(['2012-09-25','2012-09-26'])
;utr0 = time_double(['2013-11-27','2013-11-28']) ; trouble day.
;utr0 = time_double(['2015-03-16','2015-03-17']) ; trouble day.
;utr0 = time_double(['2013-03-17','2013-03-18']) ; trouble day.
;utr0 = time_double(['2012-10-09','2012-10-10']) ; trouble day.
;utr0 = time_double(['2012-09-25','2012-09-26'])
;utr0 = time_double(['2015-01-10','2015-01-11']) ; contain sdt.


; load spice kernel for all.
no_spice_load = 1
rbsp_load_spice_kernels, trange = utr0

;utr0 = time_double(['2012-11-14','2012-11-15'])
uts = smkarthm(utr0[0], utr0[1], 86400, 'dx')
foreach tut, uts do foreach tprobe, probes do rbsp_preprocess_efield, tut, no_spice_load = no_spice_load, probes=tprobe

rbsp_load_spice_kernels, trange = utr0, /unload

end
