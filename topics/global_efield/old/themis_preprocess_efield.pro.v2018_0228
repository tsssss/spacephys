;+
; on daily bases, preprocess efield for certain probe.
; subtract background E field near earth (<3 Re)
; remove bad E field when Eu and Ev do not match and
; when they are asymetric around 0.
;-


pro themis_preprocess_efield, ut0, probes = probes, write_log=write_log


;---Settings.
    if n_elements(probes) eq 0 then probes = ['a','b','c','d','e']
    rootdir = shomedir()+'/thm_efield_preprocess'
    if file_test(rootdir,/directory) eq 0 then file_mkdir, rootdir
    logfn = rootdir+'/thm_efield_preprocess.log'
    
    dt0 = 86400d
    utr = ut0-(ut0 mod dt0)+[0,dt0]
    dr0 = 1d/8      ; data rate, Hz.
    spinrate = 3    ; sec.
    minrec = 3600/dr0   ; at least 1 hr of data.
    
    deg = 180d/!dpi
    rad = !dpi/180
    re = 6378d & re1 = 1d/re

    boomlens = [50,40,6.9]*2d   ; in m.
    
    noplots = 0
    erng = 50
    
    rgb = [6,4,2]
    if ~noplots then begin
      device, decomposed = 0
      loadct2, 43
      tplot_options, 'labflag', -1
      tplot_options, 'ystyle', 1
      tplot_options, 'constant', 0
    endif
    
    
    date = time_string(utr[0],tformat='YYYY_MMDD')

    
;goto, startplot
    foreach tprobe, probes do begin
        
        pre0 = 'th'+tprobe+'_'
        
        ; Position.
        tvar = pre0+'rgsm'  ; re.
        dat = sread_thm_orbit(utr, probes=tprobe, vars=['Epoch','XYZ_GSM','DNEUTS'])
        uts = sfmepoch(dat.epoch,'unix')
        rgsm = dat.xyz_gsm
        dneuts = dat.dneuts
        idx = where(abs(dneuts) ge 10, cnt)
        if cnt ne 0 then dneuts[idx] = !values.d_nan
        store_data, tvar, uts, [[rgsm],[dneuts]], limits=$
            {ytitle:'R GSM!C(Re)', labels:['X','Y','Z','D'], colors:[rgb,0]}
      
    
;---load euvw.
    ;---thx_[euvw,egsm]
    
        ; L1 E UVW.
        tvar = pre0+'euvw'
        dat = sread_thm_eff_l1(utr, probes=tprobe)
        if size(dat,/type) ne 8 then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' no L1 E data ...'
                free_lun, lun
            endif
            return
        endif
        uts = dat.(1)
        euvw = float(dat.(0))
        if n_elements(uts) le minrec then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' L1 E data are not enough ...'
                free_lun, lun
            endif
            return
        endif
        
        
        euvw[*,2] = 0d
        for i=0,1 do euvw[*,i] *= (1d/boomlens[i])
        nrec = n_elements(uts)
        
        ; remove offset.
        eu = euvw[*,0]
        ev = euvw[*,1]
        ew = euvw[*,2]
        eu = eu-smooth(eu, spinrate/dr0, /edge_truncate, /nan)
        ev = ev-smooth(ev, spinrate/dr0, /edge_truncate, /nan)
        store_data, tvar, uts, [[eu],[ev],[ew]], limits = $
            {ytitle:'E UVW!C(mV/m)', labels:['Eu','Ev','Ew'], colors:rgb, yrange:[-1,1]*erng}


        ; L2 E GSM.    
        tvar = pre0+'egsm0'  ; dot0.
        dat = sread_thm_efi_l2(utr, probes=tprobe, vars=pre0+['eff_dot0_time','eff_dot0_gsm'])
        if size(dat,/type) ne 8 then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' no L2 E data ...'
                free_lun, lun
            endif
            return
        endif
        uts = dat.(0)
        egsm = dat.(1)
        if n_elements(egsm) ne n_elements(uts)*3 then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' L2 E data and time do not match ...'
                free_lun, lun
            endif
            return
        endif
        if n_elements(uts) le minrec then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' L2 E data are not enough ...'
                free_lun, lun
            endif
            return
        endif
        if n_elements(uts) ne nrec then begin
            if keyword_set(write_log) then begin
                openw, lun, logfn, /get_lun, /append
                printf, lun, date+': th-'+tprobe+' L2 and L1 data do not agree ...'
                free_lun, lun
            endif
            return
        endif
        store_data, tvar, uts, egsm, limits = $
            {ytitle:'E GSM!C(mV/m)', labels:['Ex','Ey','Ez'], colors:rgb, yrange:[-1,1]*erng}

        
        
    ;----flag for bad E field.
    ; thx_flag_[euv_diff,euv_asym]
    ; thx_[euv_mag,euv_mag_diff_abs,euv_avg]
        
        
        ; compare magnitude of Eu and Ev, within 2 spins.
        ; if difference in magnitude is larger than 15 mV/m, then bad field.
        maxdiff = 1
        padt = 120 ; sec.
        drec = padt/dr0
        
        wd0 = spinrate*2
        euenv = scalcenv(eu, width = wd0/dr0)
        evenv = scalcenv(ev, width = wd0/dr0)
        store_data, pre0+'euv_mag', uts, [[euenv],[evenv]], limits = $
            {ytitle:'|E|!C(mV/m)', colors:[6,4], labels:['|Eu|','|Ev|'], yrange:[-1,1]*100}
            
        euvdiff = abs(euenv-evenv)
        euvdiff = smooth(euvdiff, padt/dr0, /edge_mirror)
        store_data, pre0+'euv_mag_diff_abs', uts, euvdiff, limits = $
            {ytitle: '|Eu-Ev|!C(mV/m)', yrange:[0.01,10], ylog:1, constant:maxdiff}
        nrec = n_elements(uts)
        
        tdat = euvdiff ge maxdiff or finite(euvdiff,/nan)
        idx = where(tdat eq 1, cnt)
        for j = 0, cnt-1 do begin
            j0 = idx[j]-drec>0
            j1 = idx[j]+drec<nrec-1
            tdat[j0:j1] = 1
        endfor
        store_data, pre0+'flag_euv_diff', uts, tdat, limits = $
            {ytitle:'', yrange:[-0.5,1.5], yticks:1, yminor:0, ystyle:1, $
            labels:['1:Diff.Euv>'+sgnum2str(maxdiff)+'mV/m']}
            
            
        ; flag for bad E, when Eu and Ev are not symmetric.
        maxasym = 1 ; mV/m.
        padt = 60 ; sec.
        drec = padt/dr0
        
        get_data, pre0+'euvw', uts, tdat
        nrec = n_elements(uts)
        tdat = tdat[*,0:1]
        
        for i=0, 1 do $   ; remove spin signal.
            tdat[*,i] = smooth(tdat[*,i], spinrate/dr0, /nan, /edge_mirror)
        for i=0, 1 do tdat[*,i] = smooth(tdat[*,i], padt/dr0, /nan, /edge_mirror)
        store_data, pre0+'euv_avg', uts, tdat[*,0:1], limits = $
            {ytitle:'Euv Avg!C(mV/m)', colors:[6,4], labels:['Eu','Ev'], $
            constant:[-1,1]*maxasym, yrange:[-1,1]*maxasym*2}
        tdat = (abs(tdat) ge maxasym)
        for i = 0, 1 do begin
            idx = where(tdat[*,i] eq 1, cnt)
            for j = 0, cnt-1 do begin
                j0 = idx[j]-drec>0
                j1 = idx[j]+drec<nrec-1
                tdat[j0:j1,i] = 1
            endfor
        endfor
        store_data, pre0+'flag_euv_asym', uts, tdat, limits = $
            {ytitle:'', yrange:[-0.5,1.5], yticks:1, yminor:0, ystyle:1, $
            colors:[6,4], $
            labels:['1:Asym.Euv>'+sgnum2str(maxasym)+'mV/m','']}
            
        flagvars = pre0+'flag_'+['euv_diff','euv_asym']
        flags = dblarr(nrec)
        foreach tvar, flagvars, i do begin
            get_data, tvar, tmp, dat
            flags = flags or dat
        endforeach
        store_data, pre0+'flag_bade', uts, flags
        
        ; apply flags to egsm.
        idx = where(flags eq 1)
        get_data, pre0+'egsm0', uts, dat, limits=lim
        dat[idx,*] = !values.d_nan
        store_data, pre0+'egsm', uts, dat, limits=lim
        
;        vars = pre0+['rgsm','egsm*','euv*','flag*']
;        tplot, vars, trange=utr
        
        
        
    ;---plot: show different flags.
        tplot_options, 'labflag', -1
        if ~noplots then begin
      
        xsz = 11
        ysz = 8.5
        
        tdir = rootdir+'/th'+tprobe+'/'+time_string(ut0,tformat='YYYY')
        if file_test(tdir,/directory) eq 0 then file_mkdir, tdir
        ofn = tdir+'/'+date+'_th'+tprobe+'_bade_flag.pdf'
        
        sgopen, ofn, xsize = xsz, ysize = ysz, /inch
        device, decomposed = 0
        loadct2, 43
        xchsz = double(!d.x_ch_size)/!d.x_size
        ychsz = double(!d.y_ch_size)/!d.y_size
        
        options, flagvars, 'ytickformat', '(A1)'
        options, flagvars, 'labels', ''
        options, flagvars, 'ystyle', 1
        options, flagvars, 'yticks', 3
        options, flagvars, 'ytickv', [0,1]
        options, flagvars, 'yminor', 0
        options, flagvars, 'yticklen', 1
        options, flagvars, 'ygridstyle', 1
        options, flagvars, 'yrange', [-0.2,1.2]
        
        
        vars = pre0+['euv_avg','flag_euv_asym', 'euv_mag_diff_abs','flag_euv_diff','egsm0','egsm','rgsm']
        nvar = n_elements(vars)
        poss = sgcalcpos(nvar+1)
        poss[1,*]-= ychsz
        poss[3,*]-= ychsz
        
        ypansz = poss[3,0]-poss[1,0]
        ypad = poss[1,0]-poss[3,1]
        
        poss[1,1] = poss[3,1]-ypansz*0.3
        poss[1,3] = poss[3,3]-ypansz*0.3
        poss[3,3] = poss[1,2]-ypad
        poss[1,4] = poss[3,3]-ypansz*0.3
        poss[3,5] = poss[1,3]-(poss[1,1]-poss[3,2])
        tmp = 0.5*(poss[3,4]+poss[1,5])
        poss[1,4] = tmp+0.5*ypad
        poss[3,5] = tmp-0.5*ypad
        

        xyouts, 0.5, poss[3,0]+ychsz*0.5, /normal, alignment = 0.5, 'E UV asymmetry flag, 1 for >'+sgnum2str(maxasym)+' (mV/m)'
        xyouts, 0.5, poss[3,2]+ychsz*0.5, /normal, alignment = 0.5, 'E UV difference flag, 1 for >'+sgnum2str(maxdiff)+' (mV/m)'
        xyouts, 0.5, poss[3,4]+ychsz*0.5, /normal, alignment = 0.5, 'E GSM before and after flags are applied'
        xyouts, 0.5, poss[3,0]+ychsz*2, /normal, alignment = 0.5, $
            date+', TH-'+strupcase(tprobe)+', cover bad E', charsize = 1.25

        
        
        foreach tvar, flagvars do begin
            get_data, tvar, uts, flags
            if size(flags,/n_dimensions) eq 2 then flags = total(flags,2)<1
            idx = where(flags eq 1, cnt)
            if cnt eq 0 then continue
            dat[idx,*] = !values.d_nan
        endforeach
        store_data, pre0+'euvw', uts, dat
        
        tplot, vars, position = poss, /noerase, trange = utr

        sgclose
      endif
        
    ;---clean up the variables.    
        store_data, flagvars, /delete
        vars = pre0+['euv_mag','euv_mag_diff_abs','euv_avg']
        store_data, vars, /delete
    endforeach
end


secofday = 86400d
probes = ['a','d','e','b','c']
utr0 = time_double(['2008-01-01','2015-12-31'])
;utr0 = time_double(['2008-12-03','2015-12-31'])
;utr0 = time_double(['2009-06-01','2015-12-31'])
;utr0 = time_double(['2008-02-03','2015-12-31'])
;utr0 = time_double(['2015-03-17','2015-12-31'])
nday = (utr0[1]-utr0[0])/secofday
uts = smkarthm(utr0[0], secofday, nday+1, 'x0')

tut0 = time_double('2012-03-28')
foreach tprobe, probes do foreach tut, uts do begin
    ;if tprobe eq 'a' then if tut le tut0 then continue
    themis_preprocess_efield, tut, probes=tprobe, /write_log
endforeach

end
