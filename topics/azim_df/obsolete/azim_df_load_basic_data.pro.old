;+
; Event-based programs. Load basic data for a time range, generate an event_id, then save files.
;
; Add event_id to project as a general handler.
; data_file is output.
;-

pro azim_df_load_basic_data, time_range, event_id=event_id, project=project, reset=reset, data_file=data_file

    if n_elements(project) eq 0 then project = azim_df_load_project()
    if n_elements(time_range) eq 2 then begin
        if n_elements(event_id) eq 0 then event_id = time_string(mean(time_range),tformat='YYYY_MMDD_hh')
    endif else if n_elements(event_id) eq 0 then begin
        errmsg = handle_error('No input time_range or event_id ...')
        return
    endif

    the_key = 'event_ids'
    if ~project.haskey(the_key) then project[the_key] = list()
    event_ids = project[the_key]

    ; For detrending the tilt angle.
    the_key = 'detrend_time'
    if ~project.haskey(the_key) then project[the_key] = 80*60.  ; sec.
    detrend_time = project[the_key]
    full_time_range = time_range+[-1,1]*detrend_time
    time_step = project['time_step']
    detrend_width = detrend_time/time_step

    ; For calculating the good triad.
    the_key = 'small_angle_limit'
    if ~project.haskey(the_key) then project[the_key] = 15. ; deg.
    small_angle_limit = project[the_key]
    the_key = 'triad_angle_range'
    if ~project.haskey(the_key) then project[the_key] = [small_angle_limit,180-small_angle_limit]
    angle_range = project[the_key]

    ; For excluding irrelevent data.
    the_key = 'xsm_range'
    if ~project.haskey(the_key) then project[the_key] = [-20,4]
    xsm_range = project[the_key]
    the_key = 'dis_range'
    if ~project.haskey(the_key) then project[the_key] = minmax(abs(xsm_range))
    dis_range = project[the_key]

    ; For grouping data.
    filter_storm_setting = project.filter_storm_setting
    mlt_limit = filter_storm_setting.mlt_limit
    regions = list()
    foreach name, ['pre','post'] do begin
        the_mlt_range = (name eq 'pre')? [-1,0]: [0,1]
        the_mlt_range *= mlt_limit
        regions.add, dictionary('name', name+'_midn', $
            'mlt', the_mlt_range)
    endforeach
    nregion = n_elements(regions)


    if n_elements(data_file) eq 0 then data_file = join_path([project.data_dir,event_id+'_all_data.tplot'])
    ct = 40

    if keyword_set(reset) then begin
        index = event_ids.where(event_id)
        if index ne !null then event_ids.remove, index
        if file_test(data_file) eq 1 then file_delete, data_file
    endif

;    if event_ids.where(event_id) eq !null then begin
        save_vars = []

        del_data, '*'
        azim_df_load_data_per_event, time_range=full_time_range, filename=data_file, time_step=time_step, available_probes=available_probes

        event_ids.add, event_id
        update_project, project


    ;---Add event_info, position, tilt angle data to save_vars.
        the_var = 'event_info'
        save_vars = [save_vars,the_var]
        event_info = dictionary()
        event_info['available_probes'] = available_probes
        navailable_probe = n_elements(available_probes)
        probe_colors = smkarthm(0.,254,navailable_probe,'n')
        for jj=0, navailable_probe-1 do probe_colors[jj] = sgcolor(probe_colors[jj], ct=ct)
        event_info['probe_colors'] = probe_colors
        store_data, the_var, 0, event_info

        vars = ['r_sm','b_sm','bmod_gsm','mlat','mlt','b_tilt','bmod_tilt','db_tilt','theta']
        foreach mission_probe, available_probes do begin
            prefix = mission_probe+'_'
            foreach the_var, vars do save_vars = [save_vars,prefix+the_var]
        endforeach


    ;---Calculate the detrended tilt angle.
        foreach mission_probe, available_probes do begin
            mission_info = resolve_probe(mission_probe)
            prefix = mission_info.prefix
            get_data, prefix+'db_tilt', common_times, tilt
            tilt -= smooth(tilt, detrend_width, /nan, /edge_truncate)
            the_var = prefix+'theta'
            save_vars = [save_vars,the_var]
            store_data, the_var, common_times, tilt
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                short_name: tex2str('theta'), $
                unit: 'deg'}
        endforeach


    ;---Calculate the flag for sc that are within the magnetosphere and have data.
        ntime = n_elements(common_times)
        data_flags = bytarr(ntime,navailable_probe,nregion)
        key = 'mlt'
        foreach mission_probe, available_probes, jj do begin
            prefix = mission_probe+'_'
            mlt = get_var_data(prefix+key, at=common_times)
            foreach region, regions, kk do begin
                index = lazy_where(mlt, '[]', region[key], count=count)
                if count ne 0 then data_flags[index,jj,kk] = 1
            endforeach
            rsm = get_var_data(prefix+'r_sm', at=common_times)
            rgsm = cotran(rsm, common_times, 'sm2gsm')
            magn_flags = check_if_in_magn(rgsm)
            index = where(magn_flags eq 0, count)
            if count ne 0 then data_flags[index,jj,*] = 0
            dis = snorm(rgsm)
            index = where(dis lt min(dis_range), count)
            if count ne 0 then data_flags[index,jj,*] = 0
            tilt = get_var_data(prefix+'theta', at=common_times)
            index = where(finite(tilt,/nan), count)
            if count ne 0 then data_flags[index,jj,*] = 0
        endforeach

        foreach region, regions, jj do begin
            the_var = region['name']+'_data_flag'
            save_vars = [save_vars,the_var]
            store_data, the_var, common_times, reform(data_flags[*,*,jj])
            add_setting, the_var, /smart, {$
                yrange: [-0.2,1.2], $
                ytitle: strjoin(strsplit(the_var,'_',/extract), ' '), $
                labels: strupcase(available_probes), $
                colors: probe_colors }
        endforeach

    ;---Figure out the number of good triad.
        foreach mission_probe, available_probes do begin
            prefix = mission_probe+'_'
            the_var = prefix+'r_sm'
            rsm = get_var_data(the_var, at=common_times)
            store_data, prefix+'x_sm', common_times, rsm[*,0]
            store_data, prefix+'y_sm', common_times, rsm[*,1]
        endforeach

        ndim = 3
        foreach region, regions, jj do begin
            num_good_triads = intarr(ntime)
            the_var = region['name']+'_data_flag'
            data_flags = get_var_data(the_var, at=common_times)
            foreach time, common_times, kk do begin
                index = where(data_flags[kk,*] eq 1, count)
                if count le ndim then continue
                probes = available_probes[index]
                triads = choose_from(probes, ndim)
                ntriad = n_elements(triads)
                the_count = intarr(ntriad)
                xxs = fltarr(ndim)
                yys = fltarr(ndim)
                angles = fltarr(ndim)
                foreach triad, triads, ll do begin
                    for mm=0,ndim-1 do xxs[mm] = get_var_data(triad[mm]+'_x_sm', at=time)
                    for mm=0,ndim-1 do yys[mm] = get_var_data(triad[mm]+'_y_sm', at=time)
                    for mm=0,ndim-1 do begin
                        xxs = shift(xxs,1)
                        yys = shift(yys,1)
                        angles[mm] = sang($
                            [xxs[1]-xxs[0],yys[1]-yys[0]], $
                            [xxs[2]-xxs[0],yys[2]-yys[0]], /degree)
                    endfor
                    index = lazy_where(angles, '[]', angle_range, count=count)
                    if count eq ndim then the_count[ll] = 1 ; A good triad.
                endforeach
                num_good_triads[kk] = total(the_count)
            endforeach
            the_var = region['name']+'_triad_flag'
            save_vars = [save_vars,the_var]
            store_data, the_var, common_times, num_good_triads
            add_setting, the_var, /smart, {$
                yrange: minmax(num_good_triads)+[-1,1]*0.2, $
                ytitle: strjoin(strsplit(the_var,'_',/extract),' ') }
        endforeach
        tplot_save, save_vars, filename=data_file
;    endif else tplot_restore, filename=data_file

end

time_range = time_double(['2014-08-28/09:30','2014-08-28/11:30'])
;time_range = time_double(['2008-02-29/08:00','2008-02-29/09:00'])
azim_df_load_basic_data, time_range, project=project
end
