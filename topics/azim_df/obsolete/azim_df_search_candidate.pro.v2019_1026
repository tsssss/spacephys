;+
; Search for candidates:
;   1. Search use orbit data and availability of B field data; Search triad.
;   2. Search use Dst and AE.
;
; Write settings to project, and write results to a text file.
;-

function azim_df_search_candidate_read_file, file
    lines = read_all_lines(file)
    candidates = list()
    foreach line, lines do begin
        info = strsplit(line,' ',/extract)
        time_range = time_double(info[1:2])
        region_name = info[3]
        search_type = info[4]
        probes = strsplit(info[5],',',/extract)
        candidates.add, dictionary($
            'time_range', time_range, $
            'search_type', search_type, $
            'region', region_name, $
            'probes', probes)
    endforeach
    return, candidates
end

pro azim_df_search_candidate_search_roi, project=project


;test_time = time_double('2014-08-28/10:00')

    if ~keyword_set(test_time) then if project.done_search_candidate_search_roi then return
    lprmsg, 'Search candidate, search ROI ...'
    search_candidate = project.search_candidate
    the_key = 'search_roi'
    if ~search_candidate.haskey(the_key) then search_candidate[the_key] = dictionary()
    settings = search_candidate[the_key]
    rxy_range = [4.,40]
    mlt_limit = 9.  ; hour.
    mlt_range = [-1,1]*mlt_limit
    regions = dictionary($
        'post_midn', dictionary($
            'name', 'post_midn', $
            'mlt_range', [0, mlt_limit]), $
        'pre_midn',  dictionary($
            'name', 'pre_midn', $
            'mlt_range', [-mlt_limit,0]))
    default_settings = dictionary($
        'regions', regions, $
        'rxy_range', [4.,40], $
        'mlt_range', mlt_range, $
        'roi_min_count', 5, $
        'roi_min_duration', constant('secofhour'), $
        'roi_probe_ratio', 1.0, $
        'file_suffix', project.name+'_search_candidate_search_roi.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]


    ; Some other settings.
    flag_yrange = [-0.1,1.1]
    tplot_options, 'labflag', -1


    ; Init some settings.
    search_settings = project.search_settings
    all_probes = []
    foreach search_setting, search_settings do all_probes = [all_probes,search_setting.probes]
    all_probes = reverse(sort_uniq(all_probes)) ; reverse is a better order: themis are the first.
    probe_colors = smkarthm(50,250,n_elements(all_probes), 'n')
    probe_color_ct = 40
    foreach color, probe_colors, ii do probe_colors[ii] = sgcolor(color,ct=probe_color_ct)
    probe_infos = dictionary()
    foreach probe, all_probes, ii do begin
        probe_info = resolve_probe(probe)
        probe_info['color'] = probe_colors[ii]
        probe_infos[probe] = probe_info
    endforeach
    settings['all_probes'] = all_probes
    settings['probe_colors'] = probe_colors


;---Check if file exists, to avoid search again.
    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
    if file_test(file) then begin
        lprmsg, 'Read candidate from file ...'
        settings.candidates = azim_df_search_candidate_read_file(file)
        project.done_search_candidate_search_roi = 1
        update_project, project
        return
    endif


;---Loop through each search regime.
    roi_candidates = list()
    roi_min_duration = settings.roi_min_duration
    roi_min_count = settings.roi_min_count
    roi_probe_ratio = settings.roi_probe_ratio

    foreach search_setting, search_settings do begin
        lprmsg, 'Search '+search_setting.name+' ...'

        probes = search_setting.probes
        nprobe = n_elements(probes)
        probe_labels = strarr(nprobe)
        probe_colors = fltarr(nprobe)
        foreach probe, probes, ii do begin
            probe_labels[ii] = strupcase(probe_infos[probe].short_name)
            probe_colors[ii] = probe_infos[probe].color
        endforeach

        full_time_range = search_setting.time_range
        time_step = project.orbit_time_step
        common_times = make_bins(full_time_range, time_step)
        ncommon_time = n_elements(common_times)


    ;---Load xxx_r_gsm, xxx_r_sm.
        foreach probe, probes do begin
            azim_df_read_data, 'r_gsm', probe=probe, time_range=full_time_range, project=project
            azim_df_read_data, 'r_sm', probe=probe, time_range=full_time_range, project=project
            prefix = probe_infos[probe].prefix
            interp_time, prefix+'r_gsm', common_times
        endforeach


    ;---Flags for data in the "region of interest".
        foreach probe, probes do begin
            prefix = probe_infos[probe].prefix
            roi_flags = bytarr(ncommon_time)+1

            ; magnetopause.
            r_gsm = get_var_data(prefix+'r_gsm')
            index = where(check_if_in_magn(r_gsm) eq 0, count)
            if count ne 0 then roi_flags[index] = 0

            ; rxy.
            r_sm = get_var_data(prefix+'r_sm')
            rxy_range = settings.rxy_range
            if search_setting.name eq 'beyond_15Re' then begin
                if probe eq 'thb' or probe eq 'thc' then rxy_range >= 15.
            endif
            rxy = snorm(r_sm[*,0:1])
            index = lazy_where(rxy, '][', rxy_range, count=count)
            if count ne 0 then roi_flags[index] = 0

            ; "mlt" in SM, but really should be in MAG.
            mlt_range = settings.mlt_range
            mlt = atan(r_sm[*,1], r_sm[*,0])*constant('deg')
            ; move 0 angle from x_sm (noon) to -x_sm (midnight).
            mlt += 180
            ; convert to [-180,180].
            index = where(mlt gt 180, index)
            mlt[index] -= 360
            ; convert to hr.
            mlt *= (1d/15)
            ; save for later steps.
            store_data, prefix+'mlt', common_times, mlt
            add_setting, prefix+'mlt', /smart, {$
                display_type: 'scalar', $
                yrange: mlt_range, $
                short_name: 'MLT!USM', $
                unit: 'hr'}
            index = lazy_where(mlt, '][', mlt_range, count=count)
            if count ne 0 then roi_flags[index] = 0

            the_var = prefix+'roi_flag'
            store_data, the_var, common_times, roi_flags
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                yrange: flag_yrange, $
                short_name: strupcase(probe_infos[probe].short_name), $
                unit: 'ROI (#)'}
        endforeach

    ;---Search for each region.
        regions = settings.regions
        foreach region, regions do begin
            mlt_range = region.mlt_range
            region_name = region.name
            region_label = strupcase(strmid(region_name,0,strpos(region_name,'_')))
            lprmsg, 'Search '+region_name+' ...'

            the_var = 'roi_flag_'+search_setting.name+'_'+region_name
            roi_flags = bytarr(ncommon_time, nprobe)
            foreach probe, probes, ii do begin
                prefix = probe_infos[probe].prefix
                roi_flags[*,ii] = get_var_data(prefix+'roi_flag')
                index = lazy_where(get_var_data(prefix+'mlt'), '][', mlt_range, count=count)
                if count ne 0 then roi_flags[index,ii] = 0
            endforeach
            store_data, the_var, common_times, roi_flags, limits={$
                ytitle:region_label+'-Midn!CROI flag (#)', colors:probe_colors, labels:probe_labels, yrange:flag_yrange}

            roi_counts = total(roi_flags,2)
            the_var = 'roi_count_'+search_setting.name+'_'+region_name
            store_data, the_var, common_times, roi_counts, limits={$
                ytitle:region_label+'-Midn!CROI count (#)', labels:region_label}

            index = where(roi_counts ge roi_min_count, count)
            if count eq 0 then message, 'No candidate, stop here ...'
            times = common_times[index]
            time_ranges = time_to_range(times, time_step=time_step)
            durations = time_ranges[*,1]-time_ranges[*,0]
            index = where(durations ge roi_min_duration, count)
            if count eq 0 then message, 'No candidate, stop here ...'
            time_ranges = time_ranges[index,*]
            ntime_range = n_elements(time_ranges)/2
            for ii=0, ntime_range-1 do begin
                time_range = reform(time_ranges[ii,*])
                if keyword_set(test_time) then begin
                    index = lazy_where(test_time, '[]', time_range, count=count)
                    if count ne 0 then stop
                endif
                probe_durations = reform(total(roi_flags[lazy_where(common_times,'[]',time_range),*],1))*time_step
                index = where(probe_durations ge roi_min_duration*roi_probe_ratio, count)
                if count lt roi_min_count then begin
                    message, 'Not enough probes in ROI, skip ...', /continue
                    continue
                endif
                available_probes = probes[index]
                roi_candidates.add, dictionary($
                    'time_range', time_range, $
                    'search_type', search_setting.name, $
                    'region', region_name, $
                    'probes', available_probes)
            endfor
        endforeach
    endforeach


;---Save results.
    tab = constant('4space')
    index_format = '(I'+string(ceil(alog10(n_elements(roi_candidates))),format='(I0)')+')'
    region_names = list()
    foreach region, regions do region_names.add, region.name
    region_length = max(strlen(region_names.toarray()))
    search_names = list()
    foreach search_setting,search_settings do search_names.add, search_setting.name
    search_length = max(strlen(search_names.toarray()))

    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    foreach candidate, roi_candidates, ii do begin
        msg = string(ii,format=index_format)+tab+$
            strjoin(time_string(candidate.time_range,tformat='YYYY-MM-DD/hh:mm'),' ')+tab+$
            extend_string(candidate.region,length=region_length)+tab+$
            extend_string(candidate.search_type,length=search_length)+tab+$
            strjoin(candidate.probes,',')
        printf, lun, msg
    endforeach
    free_lun, lun



    lprmsg, 'Update project ...'
    settings.candidates = roi_candidates
    project.done_search_candidate_search_roi = 1
    update_project, project

end



pro azim_df_search_candidate_search_triad, project=project

    if project.done_search_candidate_search_triad then return
    lprmsg, 'Search candidate, search triad ...'
    search_candidate = project.search_candidate
    the_key = 'search_triad'
    if ~search_candidate.haskey(the_key) then search_candidate[the_key] = dictionary()
    settings = search_candidate[the_key]
    small_angle_limit = 15.
    triad_angle_range = [small_angle_limit,180-small_angle_limit]
    default_settings = dictionary($
        'bdata_min_ratio', 0.8, $
        'small_angle_limit', small_angle_limit, $
        'triad_angle_range', triad_angle_range, $
        'triad_min_count', 5, $
        'triad_min_duration', constant('secofhour'), $
        'triad_probe_ratio', 1.0, $
        'file_suffix', project.name+'_search_candidate_search_triad.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]


;---Check if file exists, to avoid search again.
    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
    if file_test(file) then begin
        lprmsg, 'Read candidate from file ...'
        settings.candidates = azim_df_search_candidate_read_file(file)
        project.done_search_candidate_search_triad = 1
        update_project, project
        return
    endif


    ; Some other settings.
    flag_yrange = [-0.1,1.1]
    tplot_options, 'labflag', -1
    nvertex = 3


;---Read results from last step, then loop through.
    if ~project.done_search_candidate_search_roi then azim_df_search_candidate_search_roi, project=project

    all_probes = search_candidate.search_roi.all_probes
    probe_colors = search_candidate.search_roi.probe_colors
    probe_infos = dictionary()
    foreach probe, all_probes, ii do begin
        probe_info = resolve_probe(probe)
        probe_info['color'] = probe_colors[ii]
        probe_infos[probe] = probe_info
    endforeach

    roi_candidates = search_candidate.search_roi.candidates
    roi_min_count = search_candidate.search_roi.roi_min_count
    regions = search_candidate.search_roi.regions
    triad_candidates = list()
    time_step = project.orbit_time_step
    triad_time_step = project.triad_time_step

    tab = constant('4space')
    foreach candidate, roi_candidates, ii do begin
        msg = string(ii,format='(I0)')+tab+$
            strjoin(time_string(candidate.time_range,tformat='YYYY-MM-DD/hh:mm'),' ')+tab+$
            candidate.region+tab+$
            candidate.search_type+tab+$
            strjoin(candidate.probes,',')
        lprmsg, msg

        region_name = candidate.region
        search_type = candidate.search_type
        time_range = candidate.time_range
        common_times = make_bins(time_range, time_step)
        ncommon_time = n_elements(common_times)
        probes = candidate.probes
        nprobe = n_elements(probes)

;    test_time = time_double('2014-08-28/10:00')
;;    test_time = time_double('2016-10-13/10:00')
;    index = lazy_where(test_time, '[]', time_range, count=count)
;    if count eq 0 then continue else stop


    ;---Check data availability.
        bdata_min_ratio = settings.bdata_min_ratio
        data_flags = bytarr(ncommon_time, nprobe)+1
        foreach probe, probes, jj do begin
            prefix = probe_infos[probe].prefix
            azim_df_read_data, 'bmag', probe=probe, time_range=time_range, project=project
            bmag = get_var_data(prefix+'bmag', in=time_range)   ; data rate is different, but it's ok if we only check for nans.
            nrec = n_elements(bmag)
            index = where(finite(bmag,/nan), count)
            if count gt nrec*(bdata_min_ratio) then data_flags[index,jj] = 0
        endforeach
        data_counts = total(data_flags,1)
        the_var = 'data_flag'
        the_colors = fltarr(nprobe)
        the_labels = strarr(nprobe)
        foreach probe, probes, jj do begin
            the_colors[jj] = probe_infos[probe].color
            the_labels[jj] = strupcase(probe_infos[probe].short_name)
        endforeach
        store_data, the_var, common_times, data_flags, limits={$
            ytitle:'Data flag (#)', colors:the_colors, labels:the_labels, yrange:flag_yrange}

        index = where(data_counts ge ncommon_time*bdata_min_ratio, count)
        if count lt roi_min_count then begin
            lprmsg, 'Only '+string(count,format='(I0)')+' probes have B field data ...'
            continue
        endif else begin
            if count lt nprobe then begin
                probes = probes[index]
                the_colors = the_colors[index]
                the_labels = the_labels[index]
                nprobe = count
            endif
        endelse

    ;---Check # of good triad.
        triad_common_times = make_bins(time_range, triad_time_step, /inner)
        ntriad_common_time = n_elements(triad_common_times)
        triad_angle_range = settings.triad_angle_range
        triad_min_count = settings.triad_min_count
        triad_min_duration = settings.triad_min_duration
        triad_probe_ratio = settings.triad_probe_ratio

        ; Load orbit data.
        r_sm = fltarr(ntriad_common_time, nvertex, nprobe)
        foreach probe, probes, jj do begin
            prefix = probe_infos[probe].prefix
            azim_df_read_data, 'r_sm', probe=probe, time_range=time_range, project=project
            r_sm[*,*,jj] = get_var_data(prefix+'r_sm', at=triad_common_times)
        endforeach
        r_sm = r_sm[*,0:1,*]    ; Force z=0, i.e., x-y plane.

        ; Calculate triad combos.
        combos = choose_from(probes, nvertex)
        ncombo = n_elements(combos)
        triad_flags = bytarr(ntriad_common_time,ncombo)+1
        foreach combo, combos, jj do begin
            combo_index = intarr(nvertex)
            for kk=0,nvertex-1 do combo_index[kk] = where(probes eq combo[kk])
            for kk=0,nvertex-1 do begin
                combo_index = shift(combo_index,1)
                angles = sang($
                    r_sm[*,*,combo_index[1]]-r_sm[*,*,combo_index[0]], $
                    r_sm[*,*,combo_index[2]]-r_sm[*,*,combo_index[0]], /deg)
                index = lazy_where(angles, '][', triad_angle_range, count=count)
                if count ne 0 then triad_flags[index,jj] = 0
            endfor
        endforeach
        triad_counts = total(triad_flags,2)
        index = where(triad_counts ge triad_min_count, count)
        if count eq 0 then continue
        times = triad_common_times[index]
        time_ranges = time_to_range(times, time_step=triad_time_step)
        durations = time_ranges[*,1]-time_ranges[*,0]
        index = where(durations ge triad_min_duration, count)
        if count eq 0 then continue

        time_ranges = time_ranges[index,*]
        ntime_range = n_elements(time_ranges)/2
        for jj=0, ntime_range-1 do begin
            time_range = reform(time_ranges[jj,*])
            triad_candidates.add, dictionary($
                'time_range', time_range, $
                'search_type', search_type, $
                'region', region_name, $
                'probes', probes)
            lprmsg, 'Found '+string(triad_candidates.length,format='(I0)')+' triad_candidates ...'
        endfor
    endforeach


;---Save results.
    tab = constant('4space')
    index_format = '(I'+string(ceil(alog10(n_elements(triad_candidates))),format='(I0)')+')'
    region_names = list()
    foreach region, regions do region_names.add, region.name
    region_length = max(strlen(region_names.toarray()))
    search_names = list()
    search_settings = project.search_settings
    foreach search_setting,search_settings do search_names.add, search_setting.name
    search_length = max(strlen(search_names.toarray()))

    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    foreach candidate, triad_candidates, ii do begin
        msg = string(ii,format=index_format)+tab+$
            strjoin(time_string(candidate.time_range,tformat='YYYY-MM-DD/hh:mm'),' ')+tab+$
            extend_string(candidate.region,length=region_length)+tab+$
            extend_string(candidate.search_type,length=search_length)+tab+$
            strjoin(candidate.probes,',')
        printf, lun, msg
    endforeach
    free_lun, lun


    lprmsg, 'Update project ...'
    settings.candidates = triad_candidates
    project.done_search_candidate_search_triad = 1
    update_project, project

end




pro azim_df_search_candidate_search_omni, project=project

    ;if project.done_search_candidate_search_omni then return
    lprmsg, 'Search candidate, search omni ...'
    search_candidate = project.search_candidate
    the_key = 'search_omni'
    if ~search_candidate.haskey(the_key) then search_candidate[the_key] = dictionary()
    settings = search_candidate[the_key]
    full_time_range = []
    foreach search_setting, project.search_settings do full_time_range = [full_time_range,search_setting.time_range]
    full_time_range = minmax(full_time_range)
    default_settings = dictionary($
        'time_range', full_time_range, $
        'search_type', 'substorm', $
        'omni_min_overlap', 1800., $
        'file_suffix', project.name+'_search_candidate_search_omni.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]


;---Check if file exists, to avoid search again.
    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
;    if file_test(file) then begin
;        lprmsg, 'Read candidate from file ...'
;        settings.candidates = azim_df_search_candidate_read_file(file)
;        project.done_search_candidate_search_omni = 1
;        update_project, project
;        return
;    endif



;---Loop through each candidate.
    full_time_range = settings.time_range
    omni_type = settings.search_type
    time_ranges = call_function('find_'+omni_type, full_time_range)
    time_step = project.orbit_time_step
    common_times = make_bins(full_time_range, time_step)
    ncommon_time = n_elements(common_times)
    omni_flags = bytarr(ncommon_time)
    ntime_range = n_elements(time_ranges)/2
    for ii=0, ntime_range-1 do omni_flags[lazy_where(common_times,'[]',reform(time_ranges[ii,*]))] = 1
    omni_flag_var = 'omni_'+omni_type+'_flag'
    store_data, omni_flag_var, common_times, omni_flags
    add_setting, omni_flag_var, /smart, {$
        display_type: 'scalar', $
        unit: '#', $
        short_name: strupcase(omni_type), $
        yrange: [-0.1,1.1]}

    omni_candidates = list()
    omni_min_overlap = settings.omni_min_overlap
    candidates = search_candidate.search_triad.candidates
    foreach candidate, candidates do begin
        time_range = candidate.time_range
        the_flags = omni_flags[lazy_where(common_times,'[]',time_range)]
        index = where(the_flags eq 1, count)
        overlap = count*time_step
        if overlap lt omni_min_overlap then continue
        omni_candidates.add, candidate
    endforeach

;---Save results.
    tab = constant('4space')
    index_format = '(I'+string(ceil(alog10(n_elements(omni_candidates))),format='(I0)')+')'
    region_names = list()
    regions = search_candidate.search_roi.regions
    foreach region, regions do region_names.add, region.name
    region_length = max(strlen(region_names.toarray()))
    search_names = list()
    search_settings = project.search_settings
    foreach search_setting,search_settings do search_names.add, search_setting.name
    search_length = max(strlen(search_names.toarray()))

    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    foreach candidate, omni_candidates, ii do begin
        msg = string(ii,format=index_format)+tab+$
            strjoin(time_string(candidate.time_range,tformat='YYYY-MM-DD/hh:mm'),' ')+tab+$
            extend_string(candidate.region,length=region_length)+tab+$
            extend_string(candidate.search_type,length=search_length)+tab+$
            strjoin(candidate.probes,',')
        printf, lun, msg
    endforeach
    free_lun, lun


    lprmsg, 'Update project ...'
    settings.candidates = omni_candidates
    project.done_search_candidate_search_omni = 1
    update_project, project

end




pro azim_df_search_candidate, project=project, reset=reset, fix=fix

    if n_elements(project) eq 0 then project = azim_df_load_project()

    keys = 'done_search_candidate'+['_search_roi','_search_triad','_search_omni','']
    foreach the_key, keys do begin
        if ~project.haskey(the_key) then project[the_key] = 0
        if keyword_set(reset) then project[the_key] = 0
    endforeach

    the_key = 'search_candidate'
    if ~project.haskey(the_key) then project[the_key] = dictionary()

    if keyword_set(fix) then begin
        foreach the_key, 'done_search_candidate_search_'+['roi','triad','omni'] do project[the_key] = 0
        project.done_search_candidate = 0
    endif

;    if project.done_search_candidate then begin
;        return
;    endif else begin
        azim_df_search_candidate_search_roi, project=project
        azim_df_search_candidate_search_triad, project=project
        azim_df_search_candidate_search_omni, project=project
        project.done_search_candidate = 1
        update_project, project
;    endelse

end

azim_df_search_candidate
end
