;+
; rbspx_vb1. Raw VB1.
; rbspx_eb1. Raw EB1 calculated from VB1.
; rbspx_mb1. Raw MB1 loaded from cdf file.
; rbspx_[mb1,eb1]_uvw. Detrended EB1 and MB1, assume linear background.
;-

pro _2013_0607_0456_load_burst_data

    ; settings.
    utr0 = time_double('2013-06-07/04:52'+[':57.00',':57.90'])  ; the nice wave form, 50 Hz.
    ;utr0 = time_double('2013-06-07/04:55'+[':46.00',':48.00'])  ; p = 0.015 sec, 66 Hz.
    ;utr0 = time_double(['2013-06-07/04:55:59.80','2013-06-07/04:56:00.90'])
    utr0 = time_double('2013-06-07/04:56'+[':02.00',':03.00'])  ; nice wave packet.
    ;utr0 = time_double(['2013-06-07/04:56:19.00','2013-06-07/04:56:20.40'])
    ;utr0 = time_double(['2013-06-07/04:56:25.00','2013-06-07/04:56:26.00'])

    ; chosen time, large S, during aurora, nice waveform.
    utr0 = time_double('2013-06-07/04:56'+[':02.00',':03.00'])  ; total data.
    utr1 = time_double('2013-06-07/04:56'+[':02.20',':02.80'])  ; zoom in for wave packet.

    ofn = shomedir()+'/psbl_de_32hz/2013_0607_0456_burst_data.tplot'
    tprobe='a'
    
    reload = 0
    
    
    pre0 = 'rbsp'+tprobe+'_'
    dr0 = 1d/4096
    tpad = 0.2  ; sec.
    utr = utr0+[-1,1]*tpad
    timespan, utr[0], utr[1]-utr[0], /second
    
    
    re = 6378d & re1 = 1d/re
    rgb = sgcolor(['red','green','blue'])
    c6s = sgcolor(['magenta','blue','cyan','green','yellow','red'])
    uvw = ['U','V','W']
    xyz = ['X','Y','Z']
    
    tplot_options, 'constant', 0
    tplot_options, 'labflag', -1
    tplot_options, 'num_lab_min', 5
    
    
    ; vars to be loaded and preprocessed.
    vars = ['mb1','vb1','eb1', $    ; raw data.
        'mb1_uvw','eb1_uvw', $
        ['u','v','w']+'_gsm','pos_gsm','b0_gsm','b0_uvw']
    var0s = pre0+vars
    
    
    ; vars on fac.
    fac = ['para','west','north']
    vars = [['mb1','eb1']+'_fac', $
        ['b','p','v']+'hat']
    var1s = pre0+vars
    
    
    ; vars on mat and filtering.
    cmps = ['u','v','w']
    fids = ['1','2']
    vars = ['matinfo','mb1_'+cmps+'_mat','eb1_'+cmps+'_mat', $
        'mb1_f'+fids,'eb1_f'+fids]
    var1s = pre0+vars
    
    
    allvars = [var0s,var1s]

    
    
    if file_test(ofn) eq 1 then tplot_restore, filename = ofn else reload = 1
    
    
    
    ; **** load data.
    load = 0
    foreach tvar, var0s do if tnames(tvar) eq '' then load = 1
    if reload eq 1 then load = 1
    if load then begin
        
        ; ** burst data.
        type = 'mscb1'
        tvar = pre0+'mb1'
        mb1 = sread_rbsp_efw_burst(utr, probes = tprobe, type = type)
        uts = sfmepoch(mb1.epoch,'unix')
        store_data, tvar, uts, mb1.mscb1, limits = $
            {ytitle:'(nT)', colors:rgb, labels:'dB '+uvw}
        rbsp_efw_cal_waveform, tvar, probe = tprobe, datatype = type, trange = utr
        
        type = 'vb1'
        tvar = pre0+'vb1'
        vb1 = sread_rbsp_efw_burst(utr, probes = tprobe, type = type)
        uts = sfmepoch(vb1.epoch,'unix')
        store_data, tvar, uts, vb1.vb1, limits = $
            {ytitle:'(V)', colors:c6s, labels:'V'+['1','2','3','4','5','6']}
        rbsp_efw_cal_waveform, tvar, probe = tprobe, datatype = type, trange = utr
        
        
        ; ** load UVW directions.
        defsysv,'!rbsp_spice', exists=flag
        if flag eq 0 then rbsp_load_spice_kernels, trange = utr
        
        uts = smkarthm(min(uts),max(uts),dr0*16,'dx')
        
        ; calc epoch times for spice (different than the epoch in cdfs).
        tmp = time_string(uts[0],tformat='YYYY-MM-DDThh:mm:ss.ffffff')
        cspice_str2et, tmp, tet0
        tets = tet0+uts-uts[0]
        
        scid = strupcase(pre0+'science')
        cspice_pxform, scid, 'GSM', tets, muvw2gsm
        
        ; muvw2gse[0,*,*] is u in GSM.
        ; muvw2gse[1,*,*] is v in GSM.
        ; muvw2gse[2,*,*] is w in GSM.
        store_data, pre0+'u_gsm', uts, transpose(reform(muvw2gsm[0,*,*])), $
            limits = {ytitle:'U', labels:'GSM '+xyz, colors:rgb}
        store_data, pre0+'v_gsm', uts, transpose(reform(muvw2gsm[1,*,*])), $
            limits = {ytitle:'V', labels:'GSM '+xyz, colors:rgb}
        store_data, pre0+'w_gsm', uts, transpose(reform(muvw2gsm[2,*,*])), $
            limits = {ytitle:'W', labels:'GSM '+xyz, colors:rgb}
        
        
        ; ** load B survey and sc position.
        rbsp_load_spice_state, probe = tprobe, coord = 'gsm', times = uts, /no_spice_load
        get_data, pre0+'state_pos_gsm', tmp, pos
        store_data, pre0+'state_*', /delete
        store_data, pre0+'pos_gsm', tmp, pos*re1, limits = $
            {yttile:'(Re)', colors:rgb, labels:'R GSM '+xyz}
        
        
        emfisis = sread_rbsp_emfisis_l3(utr, type = 'hires', probe = tprobe, coord = 'gsm')
        tuts = sfmepoch(emfisis.epoch,'unix')
        store_data, pre0+'b0_gsm', uts, sinterpol(emfisis.mag,tuts,uts), $
            limit = {ytitle:'(nT)', labels:'B0 GSM '+xyz, colors:rgb}
        
        ; convert B0 from gsm to uvw.
        get_data, pre0+'b0_gsm', uts, bgsm
        get_data, pre0+'u_gsm', tuts, ugsm & ugsm = sinterpol(ugsm,tuts,uts)
        get_data, pre0+'v_gsm', tuts, vgsm & vgsm = sinterpol(vgsm,tuts,uts)
        get_data, pre0+'w_gsm', tuts, wgsm & wgsm = sinterpol(wgsm,tuts,uts)
        buvw = [[sdot(bgsm,ugsm)],[sdot(bgsm,vgsm)],[sdot(bgsm,wgsm)]]
        store_data, pre0+'b0_uvw', uts, buvw, limits = $
            {ytitle:'B0 UVW!C(nT)', colors:rgb, labels:'B0 '+uvw}
    
    
        ; ** uniform time.
        ; uniform time for 'vb1','mb1','eb1', and all derived vars.
        ; rbspx_[mb1_uvw,eb1_uvw,vb1].
        tvar = pre0+'mb1'
        get_data, tvar, tuts, dat
        uts = smkarthm(min(tuts),max(tuts),dr0,'dx')
        nrec = n_elements(uts)
        dat = sinterpol(dat, tuts, uts)
        store_data, pre0+'mb1', uts, dat, limits = $
            {ytitle:'(nT)', colors:rgb, labels:'dB '+uvw}
        
        ; calc eb1 from vb1, 
        tvar = pre0+'vb1'
        get_data, tvar, tuts, dat
        dat = sinterpol(dat, tuts, uts)
        store_data, tvar, uts, dat
        dat = [(dat[*,0]-dat[*,1])/100d, (dat[*,2]-dat[*,3])/100d, $
            (dat[*,4]-dat[*,5])/12d]*1e3
        dat = reform(dat, [nrec,3])
        store_data, pre0+'eb1', uts, dat, limits = $
            {ytitle:'(mV/m)', colors:rgb, labels:'dE '+uvw}
            
            
            
        ; ** detrend, assume linear background.
        ; smoothing will reduce ~50% of the low frequency signal.
        ; trim edge > pad time.
        vars = pre0+['mb1','eb1']
        foreach tvar, vars do begin
            get_data, tvar, uts, dat, limits = lims
            for i = 0, 2 do begin
                tdat = dat[*,i]
                ; tdat = tdat-smooth(tdat, tpad/dr0, /edge_mirror)
                tdat = tdat-(tdat[0]+(tdat[nrec-1]-tdat[0])*findgen(nrec)/(nrec-1))
                dat[*,i] = tdat
            endfor
            store_data, tvar+'_uvw', uts, dat, limits = lims
        endforeach

        tplot_save, allvars, filename = ofn
    endif
    
    
    ; **** convert to FAC.
    load = 0
    foreach tvar, var2s do if tnames(tvar) eq '' then load = 1
    if reload eq 1 then load = 1
    if load then begin
    
        ; smooth B0 to remove wave.
        ; get direction for bhat, phat (west), vhat (north).
        b0p = 0.067     ; sec, the period in B0.
        b0w = 0.2       ; sec, width for smoothing.
        get_data, pre0+'vb1', uts
        get_data, pre0+'b0_uvw', tuts, dat
        dat = sinterpol(dat, tuts, uts)
        for i = 0, 2 do dat[*,i] = smooth(dat[*,i], b0w/dr0, /edge_mirror)
        bhat = sunitvec(dat)
        
        get_data, pre0+'vb1', uts
        get_data, pre0+'pos_gsm', tuts, dat
        dat = sinterpol(dat, tuts, uts)
        rhat = sunitvec(dat)
        phat = sunitvec(scross(rhat,bhat))
        vhat = scross(bhat,phat)
        
        store_data, pre0+'bhat', uts, bhat
        store_data, pre0+'phat', uts, phat
        store_data, pre0+'vhat', uts, vhat
        
        vars = pre0+['eb1','mb1']
        foreach tvar, vars do begin
            tmp = (tvar eq pre0+'eb1')? 'dE ': 'dB '
            get_data, tvar+'_uvw', uts, dat, limits = lim
            dat = [[sdot(dat,bhat)],[sdot(dat,phat)],[sdot(dat,vhat)]]
            store_data, tvar+'_fac', uts, dat, limits = $
                {ytitle:lim.ytitle, colors:rgb, labels:tmp+fac}
        endforeach
        
        tplot_save, allvars, filename = ofn
    endif
    
    stop
    
    
    ; **** filtering data.
    load = 0
    foreach tvar, var1s do if tnames(tvar) eq '' then load = 1
    if reload eq 1 then load = 1
    if load then begin
        
        ; settings for mat spectrogram.
        order = 3
        sclinfo = [2d-3,40d-3,40]           ; in sec.
        ytickvs = 1000d/[30,60,120,240]     ; in msec.
        yrng = [max(ytickvs),min(ytickvs)]  ; in msec.
        yticks = n_elements(ytickvs)-1      ; in msec.
        ytickns = strarr(yticks+1) & for i = 0, yticks do ytickns[i] = sgnum2str(1000d/ytickvs[i])
        tscales = smkgmtrc(sclinfo[0],sclinfo[1],sclinfo[2],'n')
        rscales = suniq(floor(tscales/dr0))
        tscales = rscales*dr0
        
        
        vars = pre0+['eb1','mb1']
        ztits = ['(mV/m)','10!U-3!N (nT)']
        zrngs = [6,6]
        nvar = n_elements(vars)
        for j = 0, nvar-1 do begin
            tvar = vars[j]
            get_data, tvar+'_uvw', uts, dat
            for i = 0, 2 do begin
                f0 = dat[*,i]
                f0mat = swvmat(f0, order, scale = rscales)
                if tvar eq pre0+'mb1' then f0mat *= 1e3
                store_data, tvar+'_'+cmps[i]+'_mat', uts, f0mat, tscales*1e3, $
                    limits = {ytitle:'(Hz)', spec:1, no_interp:1, $
                    ylog:1, ystyle:1, yrange:yrng, $
                    yticks:yticks, yminor:5, ytickv:ytickvs, ytickname:ytickns, $
                    ztitle:ztits[j], zrange:[-1,1]*zrngs[j], zticks:4}
            endfor
        endfor
        
        
        ; setting for filtering.
        filts = [6.04,14.02,22.02]
        nfilt = n_elements(filts)-1
        vars = pre0+['eb1','mb1']
        for i = 0, nfilt-1 do begin
            foreach tvar, vars do begin
                for j = 0, 2 do begin
                    ttvar = tvar+'_'+cmps[j]+'_mat'
                    get_data, ttvar, uts, dat, val
                    idx = where(val ge filts[i] and val lt filts[i+1])
                    f0 = total(dat[*,idx],2)
                    ; if tvar eq pre0+'mb1' then f0 *= 1e-3
                    ttvar = tvar+'_f'+fids[i]+'_'+cmps[j]
                    store_data, ttvar, uts, f0
                endfor
                tvars = tnames(tvar+'_f'+fids[i]+'_'+cmps)
                ttvar = tvar+'_f'+fids[i]
                lab = (tvar eq pre0+'eb1')? 'dE ': 'dB '
                ytit = (tvar eq pre0+'eb1')? '(mV/m)': '10!U-3!N (nT)'
                stplot_merge, tvars, newname = ttvar, ytitle = ytit, colors = rgb, $
                    labels = lab+uvw, /delete
            endforeach
        endfor

        
        info = {order:order, $  ; order = 3.
            sclinfo:sclinfo, $  ; in msec.
            ytickvs:ytickvs, $  ; tick values, in msec.
            ytickns:ytickns, $  ; ticknames, in Hz.
            filters:filts}      ; in msec.
        store_data, pre0+'matinfo', 0, info
        
        tplot_save, allvars, filename = ofn
    endif
    
    
end
