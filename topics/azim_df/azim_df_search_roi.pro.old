;+
; This is a newer version, which is more general than azim_df_search_candidate.
;
; Search for candidates in required ROI
; Write results to a text file and return.
;-

function azim_df_search_roi, search_setting, project=project, $
    reset=reset, test_time=test_time

;test_time = time_double('2014-08-28/10:00')
    retval = !null
    tab = constant('4space')

;---Settings for ROI.
    the_key = 'search_roi'
    if ~search_setting.haskey(the_key) then message, 'No settings for ROI ...'
    search_info = search_setting[the_key]



;---Check if file exists, to avoid search again.
    file_suffix = search_info.file_suffix
    out_file = join_path([project.data_dir,file_suffix])
    if keyword_set(reset) then begin
        lprmsg, 'Resetting ROI search ...'
        file_delete, out_file, /allow_nonexistent
        lprmsg, 'Clear memory ...'
        del_data, '*'
    endif
    if file_test(out_file) eq 1 then begin
        if file_lines(out_file) eq 0 then file_delete, out_file
    endif

    if file_test(out_file) eq 0 then begin
        candidate_id = 0

        roi_min_duration = search_info.roi_min_duration
        pdyn = search_info.pdyn
        overall_rxy_range = search_info.rxy_range
        overall_mlt_range = search_info.mlt_range
        lprmsg, 'Searching candidates in the overal ROI ...'
        lprmsg, tab+'MLT range (hr): ['+strjoin(string(overall_mlt_range,format='(I0)'),',')+']'
        lprmsg, tab+'Rxy range (Re): ['+strjoin(string(overall_rxy_range,format='(I0)'),',')+']'
        lprmsg, tab+'Magnetopause model Pdyn (nPa) = '+string(pdyn,format='(I0)')
        lprmsg, tab+'Min duration (min): '+string(roi_min_duration/60,format='(I0)')


    ;---Loop through each search type.
        probe_infos = project.probe_infos
        search_name = search_info.name
        lprmsg, ''
        lprmsg, 'Searching name: '+search_name+' ...'

        ; All probes to be searched.
        probes = search_setting.probes
        nprobe = n_elements(probes)
        probe_labels = strarr(nprobe)
        probe_colors = fltarr(nprobe)
        foreach probe, probes, ii do begin
            probe_labels[ii] = strupcase(probe_infos[probe].short_name)
            probe_colors[ii] = probe_infos[probe].color
        endforeach
        lprmsg, tab+'Probes: '+strjoin(probes, ',')+' ...'

        ; Time range to be searched.
        full_time_range = search_setting.time_range
        time_step = project.search_candidate_time_step
        common_times = make_bins(full_time_range, time_step)
        ncommon_time = n_elements(common_times)
        lprmsg, tab+'Time range: '+strjoin(time_string(full_time_range,tformat='YYYY-MM-DD'), ' to ')+' ...'

        ; Required probes in ROI.
        required_probes = search_info.roi_probes
        msg = (n_elements(required_probes) eq 0)? 'N/A': strupcase(strjoin(required_probes,','))
        lprmsg, tab+'Required probes in ROI: '+msg

        ; Required # of probes in ROI.
        roi_min_count = search_info.roi_min_count
        lprmsg, tab+'Minimum # of probes in ROI: '+string(roi_min_count,format='(I0)')


    ;---Load xxx_r_sm.
        lprmsg, tab+'Loading orbit data ...'
        foreach probe, probes do begin
            lprmsg, tab+tab+'Processing '+strupcase(probe)+' ...'
            azim_df_read_data, 'r_sm', probe=probe, time_range=full_time_range, project=project
            azim_df_read_data, 'r_gsm', probe=probe, time_range=full_time_range, project=project
            prefix = probe_infos[probe].prefix
            interp_time, prefix+'r_sm', common_times
            interp_time, prefix+'r_gsm', common_times
            ; G14 do not have data for a significant fraction of times.
            if probe eq 'g14' then begin
                lprmsg, tab+tab+'Removing times when G14 does not have data ...'
                azim_df_read_data, 'bmag', probe=probe, time_range=full_time_range, project=project
                get_data, 'g14_bmag', times, bmag
                data_flag = finite(bmag,/nan)
                index = where(data_flag eq 1, count)
                if count ne 0 then begin
                    data_flag = interpol(data_flag, times, common_times)
                    index = where(data_flag eq 1, count)
                    foreach var, 'g14_'+['r_gsm','r_sm'] do begin
                        get_data, var, times, data
                        data[index,*] = !values.f_nan
                        store_data, var, times, data
                    endforeach
                endif
            endif
        endforeach


    ;---Flags for each probe when it is in the "region of interest".
        foreach probe, probes do begin
            lprmsg, tab+tab+'Processing '+strupcase(probe)+' ...'
            prefix = probe_infos[probe].prefix
            roi_flags = bytarr(ncommon_time)+1

            ; magnetopause.
            r_gsm = get_var_data(prefix+'r_gsm')
            index = where(check_if_in_magn(r_gsm, dynamic_pressure=pdyn) eq 0, count)
            if count ne 0 then roi_flags[index] = 0

            ; rxy.
            r_sm = get_var_data(prefix+'r_sm')
            rxy_range = overall_rxy_range
            if search_info.name eq 'beyond_15Re' then begin
                if probe eq 'thb' or probe eq 'thc' then rxy_range >= 15.
            endif
            rxy = snorm(r_sm[*,0:1])
            the_var = prefix+'rxy'
            store_data, the_var, common_times, rxy
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                yrange: rxy_range, $
                short_name: '|R!Dxy!N|', $
                unit: 'Re'}
            index = lazy_where(rxy, '][', rxy_range, count=count)
            if count ne 0 then roi_flags[index] = 0

            ; "mlt" in SM, but really should be in MAG.
            mlt = azim_df_calc_pseudo_mlt(r_sm)
            mlt_range = overall_mlt_range
            the_var = prefix+'mlt'
            store_data, the_var, common_times, mlt
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                yrange: mlt_range, $
                short_name: 'MLT!USM', $
                unit: 'hr'}
            index = lazy_where(mlt, '][', mlt_range, count=count)
            if count ne 0 then roi_flags[index] = 0

            ; Stay in ROI longer than roi_min_duration.
            index = where(roi_flags eq 1, count)
            if count ne 0 then begin
                time_ranges = time_to_range(common_times[index], time_step=time_step)
                durations = time_ranges[*,1]-time_ranges[*,0]
                index = where(durations ge roi_min_duration, count)
                if count ne 0 then begin
                    roi_flags[*] = 0
                    time_ranges = time_ranges[index,*]
                    ntime_range = n_elements(time_ranges)/2
                    for ii=0, ntime_range-1 do roi_flags[lazy_where(common_times,'[]',reform(time_ranges[ii,*]))] = 1
                endif
            endif

            the_var = prefix+'roi_flag'
            store_data, the_var, common_times, roi_flags
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                yrange: [-0.1,1.1], $
                short_name: strupcase(probe_infos[probe].short_name), $
                unit: '#'}
        endforeach


    ;---Search for each region.
        mlt_range = search_info.mlt_range
        region_name = search_setting.name
        region_label = strupcase(strmid(region_name,0,strpos(region_name,'_')))
        lprmsg, ''
        lprmsg, tab+'Search in '+region_name+' ...'

    ;---Combine all flags into one.
        roi_flag_var = 'roi_flag_'+search_name+'_'+region_name
        roi_flags = intarr(ncommon_time, nprobe)
        foreach probe, probes, ii do begin
            prefix = probe_infos[probe].prefix
            roi_flags[*,ii] = get_var_data(prefix+'roi_flag')
            index = lazy_where(get_var_data(prefix+'mlt'), '][', mlt_range, count=count)
            if count ne 0 then roi_flags[index,ii] = 0
        endforeach
        store_data, roi_flag_var, common_times, roi_flags, limits={$
            ytitle:region_label+'-Midn!CROI flag (#)', colors:probe_colors, labels:probe_labels, yrange:[-0.1,1.1]}

    ;---Count of # of probes in ROI at each time tag.
        roi_counts = total(roi_flags,2)
        roi_count_var = 'roi_count_'+search_name+'_'+region_name
        store_data, roi_count_var, common_times, roi_counts, limits={$
            ytitle:region_label+'-Midn!CROI count (#)', labels:region_label}


    ;---Find the times when there are enough probes, and all required probes are present.
        lprmsg, tab+tab+'Checking # of probes in ROI ...'
        time_index = roi_counts ge roi_min_count
        index = where(time_index eq 1, count)
        if count eq 0 then message, 'No candidate, stop here ...'
        if n_elements(required_probes) ne 0 then begin
            lprmsg, tab+tab+'Checking the existence of required probes ...'
            nrequired_probe = n_elements(required_probes)
            probe_index = intarr(nrequired_probe)
            foreach probe, required_probes, ii do probe_index[ii] = where(probes eq probe)
            roi_required_counts = total(roi_flags[*,probe_index],2)
            time_index = time_index and (roi_required_counts eq nrequired_probe)
            index = where(time_index eq 1, count)
            if count eq 0 then lprmsg, 'No candidate, stop here ...'
        endif
        times = common_times[index]


    ;---Rule out time ranges that are too short.
        lprmsg, tab+tab+'Excluding time ranges that are too short ...'
        time_ranges = time_to_range(times, time_step=time_step)
        durations = time_ranges[*,1]-time_ranges[*,0]
        index = where(durations gt roi_min_duration, count)
        if count eq 0 then lprmsg, 'No candidate, stop here ...'
        time_ranges = time_ranges[index,*]


    ;---Break down into pieces when probes are fixed.
        lprmsg, tab+tab+'Writing results to file: '+out_file+' ...'
        ftouch, out_file
        ntime_range = n_elements(time_ranges)/2
        for ii=0, ntime_range-1 do begin
            time_range = reform(time_ranges[ii,*])
            if keyword_set(test_time) then if product(candidate.time_range-test_time) lt 0 then stop
            candidate_id += 1
            candidate = dictionary($
                'id', candidate_id, $
                'time_range', time_range, $
                'duration', total(time_range*[-1,1])/60, $  ; in min.
                'nsection', 0, $
                'search_name', search_name, $
                'region', region_name, $
                'all_probes', !null, $
                'time_range_list', list(), $
                'probe_list', list())

            index = lazy_where(common_times,'[]',time_range)
            the_roi_flags = roi_flags[index,*]
            the_times = common_times[index]
            probe_counts = total(the_roi_flags, 1)
            index = where(probe_counts ne 0, navailable_probe)
            if navailable_probe lt roi_min_count then message, 'Inconsistency, stop here ...'
            the_roi_flags = the_roi_flags[*,index]

            boundarys = time_range
            if navailable_probe gt roi_min_count then begin
                diff = fix(abs(the_roi_flags[1:-1,*]-the_roi_flags[0:-2,*]))
                diff = total(diff,2)
                index = where(diff ge 1, count)
                if count ne 0 then boundarys = [boundarys, the_times[index+1]]
            endif
            boundarys = sort_uniq(boundarys)
            nsection = n_elements(boundarys)-1
            time_range_list = list()
            probe_list = list()
            for jj=0, nsection-1 do begin
                the_time_range = boundarys[jj:jj+1]
                the_roi_flags = roi_flags[lazy_where(common_times,'[)',the_time_range),*]
                probe_counts = total(the_roi_flags, 1)
                available_probes = probes[where(total(the_roi_flags,1) ne 0)]
                time_range_list.add, the_time_range
                probe_list.add, available_probes
            endfor
            candidate.nsection = nsection
            candidate.probe_list = probe_list
            candidate.time_range_list = time_range_list

            ; Get all probes for all sections.
            all_section_probes = []
            for jj=0, nsection-1 do all_section_probes = [all_section_probes,candidate.probe_list[jj]]
            all_section_probes = sort_uniq(all_section_probes)
            candidate['all_probes'] = all_section_probes

            ; Write to file.
            azim_df_search_candidate_write_file, candidate, filename=out_file
        endfor

        lprmsg, tab+'Updating project ...'
        update_project, project

        lprmsg, tab+'Done search ROI ...'
    endif


    lprmsg, ''
    lprmsg, 'Read ROI candidate from file ...'
    roi_candidates = azim_df_search_candidate_read_file(out_file)
    return, roi_candidates

end
