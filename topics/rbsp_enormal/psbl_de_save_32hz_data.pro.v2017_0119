;+
; download rbsp 'raw' data, plot the wanted data to disk.
; save necessary data, e.g., the ones uses spice kernel.
; data that are easy to load are not saved, e.g., HOPE spec.
; data that are derived are left for a later routine, e.g., FAC, GSE fields.
;-
pro psbl_de_plot_32hz_data, id, trange = utr, rootdir = rootdir

    if n_elements(id) eq 0 then message, 'no id ...'
    if n_elements(tprobe) eq 0 then tprobe = strmid(id,strlen(id)-1)
    if n_elements(utr) eq 0 then $
        utr = time_double(strmid(id,0,14),tformat='YYYY_MMDD_hhmm')+[-2,8]*60
    if n_elements(rootdir) eq 0 then rootdir = shomedir()+'/psbl_de_32hz'

    datadir = rootdir+'/data'
    datavar = []
    plotvar = []
    lablvar = []
    
    ; expand utr to at least 10 min.
    utr = mean(utr) & utr = utr-(utr mod 60) & utr+= [-1,1]*0.5*600

    
    pre0 = 'rbsp'+tprobe+'_'
    deg = 180d/!dpi
    rad = !dpi/180
    re = 6378d & re1 = 1d/re
    minratio = 0.1  ; Bx/B ratio in MGSE>
    rgb = [6,4,2]
    dt0 = 86400d
    utr0 = utr-(utr mod dt0)+[0,dt0]
    timespan, utr0[0], dt0, /second
    
    tplot_options, 'constant', 0
    tplot_options, 'num_lab_min', 10
    tplot_options, 'labflag', -1
    tplot_options, 'ynozero', 1
    tplot_options, 'ymargin', [5,5]
    tplot_options, 'xmargin', [25,15]
    
    
; **** load E field. 32Hz dE MGSE.
; rbspx_de_mgse

    tvar = pre0+'de_mgse'
    dat = sread_rbsp_efw_l2(utr, probes = tprobe, type = 'esvy')
    if size(dat,/type) ne 8 then message, 'no E data ...'
    tmp = sfmepoch(dat.epoch, 'unix')
    dr = sdatarate(tmp[sort(tmp)])
    uts = smkarthm(min(tmp), max(tmp), dr, 'dx')    ; get uniform time.
    dat = sinterpol(dat.efield_mgse, tmp, uts)
    dat[*,0] = 0.   ; set x to 0.
    store_data, tvar, uts, dat, limits = $
        {ytitle:'dE MGSE!C(mV/m)', colors:rgb, $
        labels:'MGSE '+['x','y','z'], constant:[-25,0,25]}
    
    datavar = [datavar,pre0+'de_mgse']
    plotvar = [plotvar,pre0+'de_mgse']
    

; **** load position.
; rbspx_[mlt,lshell,ilat,pos_gse].

    efwl3 = sread_rbsp_efw_l3(utr0, probes = probe)
    if size(efwl3,/type) ne 8 then return
    uts = sfmepoch(efwl3.epoch,'unix',/epoch16)
    
    store_data, pre0+'mlt', uts, (efwl3.mlt_lshell_mlat)[*,0], $
        limits = {ytitle:'MLT (hr)'}
    store_data, pre0+'lshell', uts, (efwl3.mlt_lshell_mlat)[*,1], $
        limits = {ytitle:'L (Re)'}
    store_data, pre0+'ilat', uts, acos(1/sqrt((efwl3.mlt_lshell_mlat)[*,1]))*deg, $
        limits = {ytitle:'ILat (deg)'}
    store_data, pre0+'mlat', uts, (efwl3.mlt_lshell_mlat)[*,2], $
        limits = {ytitle:'MLat (deg)'}
    store_data, pre0+'pos_gse', uts, efwl3.pos_gse, $
        limits = {colors:rgb, labels:['x','y','z']}

    datavar = [datavar,pre0+['mlt','lshell','ilat','pos_gse']]


; **** load B field. l3, gse, emfisis, hires 171 MB for 1 day.
; rbspx_b_gse, rbspx_b.

    emfisis = sread_rbsp_emfisis_l3(utr, probes = tprobe, type = 'hires')
    if size(emfisis,/type) ne 8 then message, 'no B data ...'
    uts = sfmepoch(emfisis.epoch,'unix')
    store_data, pre0+'b_gse', uts, emfisis.mag, $
        limits = {ytitle:'B!C(nT)',colors:rgb, labels:'GSE '+['x','y','z']}
    store_data, pre0+'b', uts, sqrt(total(emfisis.mag^2,2)), $
        limits = {ytitle:'B magnitude!C(nT)'}
    
    datavar = [datavar,pre0+'b_gse']
    plotvar = [plotvar,pre0+'b_gse']

    
;; **** load HOPE spectrograms.
;; rbspx_[e,p]_enspec.
;    dat = sread_rbsp_hope_l3(utr0, probes = tprobe, type = 'pa')
;    if size(dat,/type) eq 8 then begin
;        npa = n_elements(dat.pitch_angle)
;        uts = sfmepoch(dat.epoch_ele, 'unix')
;        store_data, pre0+'e_enspec', uts, reform(total(dat.fedu,3,/nan)), $
;            dat.hope_energy_ele, limits = {ytitle:'Electron!CEnergy (eV)',spec:1, $
;            no_interpol:1, ylog:1, zlog:1, yrange:[10,4e4], zrange:[1e7,1e9], $
;            ztitle:'(s!E-1!Ncm!E-2!Nster!E-1!NkeV!E-1!N)', ystyle:1}
;        uts = sfmepoch(dat.epoch_ion, 'unix')
;        store_data, pre0+'p_enspec', uts, reform(total(dat.fpdu,3,/nan)), $
;            dat.hope_energy_ion, limits = {ytitle:'Proton!CEnergy (eV)',spec:1, $
;            no_interpol:1, ylog:1, zlog:1, yrange:[10,4e4], zrange:[1e5,1e7], $
;            ztitle:'(s!E-1!Ncm!E-2!Nster!E-1!NkeV!E-1!N)', ystyle:1}
;    endif else begin
;        store_data, pre0+'e_enspec', 0, 0
;        store_data, pre0+'p_enspec', 0, 0
;    endelse
;    
;    datavar = [datavar,pre0+['e_enspec','p_enspec']]
;    plotvar = [plotvar,pre0+['e_enspec','p_enspec']]
;    
;    ; use the z-value to set the zrange.
;    tvar = pre0+'e_enspec'
;    get_data, tvar, uts, dat, val
;    idx = where(uts ge utr[0] and uts le utr[1], cnt)
;    if cnt gt 0 then begin
;        dat = dat[idx,*,*]
;        tmp = where(dat eq 0, cnt)
;        if cnt ne 0 then dat[tmp] = !values.d_nan
;        val = reform(val[idx[0],*])
;        minen = 100     ; eV.
;        tmp = min(val-minen, tidx, /absolute)
;        vmax = median(dat[*,tidx])
;        if finite(vmax) then vmax = 10d^(ceil(alog10(vmax))) else begin
;            vmax = max(dat,/nan)
;            if finite(vmax) then vmax = 10d^(floor(alog10(vmax))) else vmax = 1e8
;        endelse
;        maxen = 10000   ; eV.
;        tmp = min(val-maxen, tidx, /absolute)
;        vmin = median(dat[*,tidx])
;        if finite(vmin) then vmin = 10d^(floor(alog10(vmin))) else begin
;            vmin = min(dat,/nan)
;            if finite(vmin) then vmin = 10d^(ceil(alog10(vmin))) else vmin = 1e4
;        endelse
;        options, tvar, 'zrange', [vmin,vmax]
;;        scl = alog10(vmax/vmin)
;;        if scl le 2 or scl le 4 then options, tvar, 'zrange', [1e4,1e8]
;        
;        tvar = pre0+'p_enspec'
;        get_data, tvar, uts, dat, val
;        dat = dat[idx,*,*]
;        tmp = where(dat eq 0, cnt)
;        if cnt ne 0 then dat[tmp] = !values.d_nan
;        vmax = max(dat, /nan)
;        if finite(vmax) then vmax = 10d^(floor(alog10(vmax))) else vmax = 1e7
;        vmin = min(dat, /nan)
;        if finite(vmin) then vmin = 10d^(ceil(alog10(vmin))) else vmin = 1e5
;        options, tvar, 'zrange', [vmin,vmax]
;;        scl = alog10(vmax/vmin)
;;        if scl le 2 or scl le 4 then options, tvar, 'zrange', [1e5,1e7]
;    endif
    


; **** load HOPE moments.
; rbspx_[n,t].
    hopemom = sread_rbsp_hope_l3(utr0, probes = tprobe, type = 'mom')
    if size(hopemom,/type) eq 8 then begin
        uts = sfmepoch(hopemom.epoch_ele,'unix')
        store_data, pre0+'n', uts, hopemom.dens_e_200, $
            limits = {ytitle:'N!Ie!N!C(cm!E-3!N)', ylog:1, constant:1}

        store_data, pre0+'t', uts, [[hopemom.tperp_e_200],[hopemom.tpar_e_200]], $
            limits = {ytitle:'T!Ie!I!N!C(eV)', ylog:1, colors:[6,0], $
            labels:['Tperp','Tpara'], constant:1000}
        tvar = pre0+'t'
        get_data, tvar, uts, dat
        idx = where(dat eq 1e20, cnt)
        if cnt ne 0 then dat[idx] = !values.d_nan
        store_data, tvar, uts, dat
    endif else begin
        store_data, pre0+'n', 0, 0
        store_data, pre0+'t', 0, 0
    endelse
        
    datavar = [datavar,pre0+['n','t']]
    plotvar = [plotvar,pre0+['n','t']]
    
    ; use the dynamic range to set yrange.
    get_data, pre0+'n', uts
    idx = where(uts ge utr[0] and uts le utr[1], cnt)
    if cnt ne 0 then begin
        foreach tvar, pre0+['n','t'] do begin
            get_data, tvar, uts, dat
            dat = dat[idx]
            uts = uts[idx]
            tmin = min(dat,/nan)
            tmax = max(dat,/nan)
            scl = 10^ceil(alog10(tmax/tmin))
            ymax = double(ceil(sqrt(tmin*tmax*scl)))
            ymin = ymax/scl
            options, tvar, 'yrange', [ymin,ymax]
            options, tvar, 'ystyle', 1
        endforeach
    endif


; **** omni Dst and AE.
; ae,dst.
    omni = sread_omni(utr)
    uts = sfmepoch(omni.epoch,'unix')
    store_data, 'dst', uts, omni.sym_h, limits = {ytitle:'Dst (nT)'}
    store_data, 'ae', uts, omni.ae_index, limits = {ytitle:'AE (nT)'}
    
    datavar = [datavar,['dst','ae']]
    lablvar = [lablvar,['dst','ae']]


; **** trim data to utr.
    for j = 0, n_elements(datavar)-1 do begin
        get_data, datavar[j], tuts, tdat
        idx = where(tuts ge utr[0] and tuts le utr[1])
        store_data, datavar[j], tuts[idx], tdat[idx,*,*,*]
    endfor


; **** mapping coefficient, footpoint.
; rbspx_fpt_[mlon,mlat,mlt].
    model = 't89'
    r0 = 1+110d*re1
    ; map pos to fpt, convert to mag.
    get_data, pre0+'pos_gse', data = tmp
    uts = tmp.x
    nrec = n_elements(uts)
    pos0 = tmp.y*re1 ; pos gse in re.
    pos1 = pos0      ; pos gsm in re.
    ets = stoepoch(uts, 'unix')
    fptbs = dblarr(nrec)
    ; loop for each time.
    for j = 0, nrec-1 do begin
        ; set geopack.
        geopack_epoch, ets[j], yr, mo, dy, hr, mi, sc, msc, /breakdown_epoch
        geopack_recalc, yr, mo, dy, hr, mi, sc+msc*0.001D, /date
        ; pos in gse, which is the mapping coord.
        x0 = pos0[j,0] & y0 = pos0[j,1] & z0 = pos0[j,2]
        ; convert from gse to gsm.
        geopack_conv_coord, x0, y0, z0, /from_gse, $
            x1, y1, z1, /to_gsm
        dir = (z1 gt 0)? -1: 1
        par = 2     ; set kp = 2 for t89.
        geopack_trace, x1, y1, z1, dir, par, xf, yf, zf, $
            epoch = ets[j], /refine, /ionosphere, $
            t89 = t89, t96 = t96, t01 = t01
        ; convert from gsm to mag.
        geopack_conv_coord, xf, yf, zf, /from_gsm, $
            x1, y1, z1, /to_mag
        pos1[j,*] = [x1,y1,z1]
        ; get internal field.
        geopack_igrf_gsm, xf,yf,zf, bxf,byf,bzf
        fptbs[j] = sqrt(bxf^2+byf^2+bzf^2)
    endfor
    mlat = asin(pos1[*,2]*(1/r0))*deg
    mlon = atan(pos1[*,1],pos1[*,0])*deg
    store_data, pre0+'fpt_mlon', uts, mlon, $
        limits = {ytitle:'MLon/fpt (deg)'}
    store_data, pre0+'fpt_mlat', uts, mlat, $
        limits = {ytitle:'MLat/fpt (deg)'}
    store_data, pre0+'fpt_mlt', uts, slon2lt(mlon, stoepoch(uts,'unix'), /mag, /deg)/15, $
        limits = {ytitle:'MLT/fpt (hr)'}
    get_data, pre0+'b', tmp, bs
    bs = interpol(bs, tmp, uts)
    store_data, pre0+'map_coef', uts, bs/fptbs

    datavar = [datavar,pre0+['fpt_mlon','fpt_mlat','fpt_mlt','map_coef']]


; **** some preparation. get b0 and db from b, interpolate E/B to uniform time.
    get_data, pre0+'de_mgse', uts
    dr = sdatarate(uts)
    uts = smkarthm(min(uts), max(uts), dr, 'dx')
    nrec = n_elements(uts)
    vars = pre0+['de_mgse','b_gse','b']
    for i = 0, n_elements(vars)-1 do begin
        get_data, vars[i], tuts, tdat
        store_data, vars[i], uts, sinterpol(tdat, tuts, uts)
    endfor

;    get_data, pre0+'b_gse', uts, bgse
;    b0gse = bgse
;    for i = 0, 2 do b0gse[*,i] = scalcbg(bgse[*,i])
;    store_data, pre0+'b0_gse', uts, b0gse
;    store_data, pre0+'db_gse', uts, bgse-b0gse

    ; get w_gse, will be used to convert b/w GSE and mGSE.
    wgse = dblarr(nrec,3)
    rbsp_load_spice_kernels, probe = tprobe, trange = utr
    for i = 0, nrec-1 do begin
        tstr = time_string(uts[i], tformat = 'YYYY-MM-DDThh:mm:ss.ffffff')
        cspice_str2et, tstr, et
        cspice_pxform, 'RBSP'+tprobe+'_SCIENCE', 'GSE', et, pxform
        wgse[i,*] = pxform[2,*]
    endfor
    idx = fix(smkarthm(0,nrec,10,'n'))
    store_data, pre0+'wgse', tuts[idx], wgse[idx,*], limits = $
        {ytitle:'W GSE!Cunit vector', labels:'GSE '+['x','y','z'], colors:[6,4,2]}

    datavar = [datavar,pre0+'wgse']


;; **** rotate b/w GSE and mGSE.
;    rbsp_mgse2gse, pre0+'de_mgse', wgse, newname = pre0+'de_gse'
;    get_data, pre0+'de_gse', t0, de_gse
;    get_data, pre0+'b_gse', tmp, db_gse
;    db_gse = sinterpol(db_gse, tmp, t0)
;    store_data, pre0+'b_gse', t0, db_gse
;    rbsp_mgse2gse, pre0+'b_gse', newname = pre0+'b_mgse', /inverse
;    get_data, pre0+'b_mgse', tmp, b_mgse
;    get_data, pre0+'de_mgse', t0, de_mgse
;    de_mgse[*,0] = -(b_mgse[*,1]*de_mgse[*,1]+b_mgse[*,2]*de_mgse[*,2])/b_mgse[*,0]
;    ratio = abs(b_mgse[*,0])/snorm(b_mgse)
;    store_data, pre0+'bx_ratio', t0, ratio
;    idx = where(ratio le minratio, cnt)
;    if cnt ne 0 then de_mgse[idx,0] = !values.d_nan
;    store_data, pre0+'de_dot0_mgse', t0, de_mgse
;    rbsp_mgse2gse, pre0+'de_dot0_mgse', wgse, newname = pre0+'de_dot0_gse'
;    
;    tvar = pre0+'bx_ratio'
;    options, tvar, 'ytitle', 'Bx/B MGSE'
;    ylim, tvar, 0,1, 0
;    options, tvar, 'constant', minratio
;    
;    tvar = pre0+'de_dot0_gse'
;    options, tvar, 'colors', rgb
;    options, tvar, 'labels', 'dot0 GSE '+['x','y','z']
;    options, tvar, 'ytitle', 'dE dot0!C(mV/m)'
;    tvar = pre0+'de_dot0_mgse'
;    options, tvar, 'colors', rgb
;    options, tvar, 'labels', 'dot0 MGSE '+['x','y','z']
;    options, tvar, 'ytitle', 'dE dot0!C(mV/m)'
;    tvar = pre0+'b_mgse'
;    options, tvar, 'colors', rgb
;    options, tvar, 'labels', 'MGSE '+['x','y','z']
;    options, tvar, 'ytitle', 'B!C(nT)'
;    tvar = pre0+'de_gse'
;    options, tvar, 'colors', rgb
;    options, tvar, 'labels', 'GSE '+['x','y','z']
;    options, tvar, 'ytitle', 'dE!C(mV/m)'
;
;
;; **** calc FAC fields.
;; rbspx_[de,db]_fac.
;    ; FAC dE. ex is along b, ey is east-west, ez is up.
;    get_data, pre0+'de_gse', data = de
;    get_data, pre0+'de_dot0_gse', data = dedot0
;    get_data, pre0+'db_gse', data = db
;    get_data, pre0+'b0_gse', data = tmp
;    bmod = sinterpol(tmp.y, tmp.x, de.x)
;    db = sinterpol(db.y, db.x, de.x)
;    bhat = sunitvec(bmod)
;    
;    p = atan(bhat[*,1],bhat[*,0])
;    cosp = cos(p) & sint = bhat[*,2]
;    cost = bhat[*,0]/cosp & sinp = bhat[*,1]/cost
;    
;    tmp = de.y
;    ex = cost*cosp*tmp[*,0] + cost*sinp*tmp[*,1] - sint*tmp[*,2]
;    ey = -sinp*tmp[*,0] + cosp*tmp[*,1]
;    ez = sint*sinp*tmp[*,0] + sint*cosp*tmp[*,2] + cost*tmp[*,2]
;    store_data, pre0+'de_fac', data = {x:de.x, y:[[ex],[ey],[ez]]}, $
;        limits = {colors:rgb, labels:'dE FAC '+['b','p','v'], ytitle:'dE!C(mV/m)'}
;    
;    tmp = dedot0.y
;    ex = cost*cosp*tmp[*,0] + cost*sinp*tmp[*,1] - sint*tmp[*,2]
;    ey = -sinp*tmp[*,0] + cosp*tmp[*,1]
;    ez = sint*sinp*tmp[*,0] + sint*cosp*tmp[*,2] + cost*tmp[*,2]
;    store_data, pre0+'de_dot0_fac', data = {x:dedot0.x, y:[[ex],[ey],[ez]]}, $
;        limits = {colors:rgb, labels:'dE dot0 FAC '+['b','p','v'], ytitle:'dE!C(mV/m)'}
;
;    tmp = db
;    bx = cost*cosp*tmp[*,0] + cost*sinp*tmp[*,1] - sint*tmp[*,2]
;    by = -sinp*tmp[*,0] + cosp*tmp[*,1]
;    bz = sint*sinp*tmp[*,0] + sint*cosp*tmp[*,2] + cost*tmp[*,2]
;    store_data, pre0+'db_fac', data = {x:dedot0.x, y:[[bx],[by],[bz]]}, $
;        limits = {colors:rgb, labels:'dB FAC '+['b','p','v'], ytitle:'dB!C(nT)'}



;; **** calc Poynting flux.
;    tfilters = [0,1,15,60,250]
;    filterids = ['1','2','3','4']
;    nfilter = 2
;    coordlabs = ['b','p','v']
;    rgb = [6,4,2]
;    dt = 10*60  ; 10 min.
;    sclinfo = [0.1,dt/2,40]
;    
;    denames = pre0+['de_fac','de_dot0_fac']
;    dbnames = pre0+['db_fac','db_fac']
;    pfnames = pre0+['pf_fac','pf_dot0_fac']
;    suffixs = '_mat'+filterids
;    
;    ; calc poynting flux.
;    for i = 0, n_elements(denames)-1 do begin
;        dename = denames[i]
;        dbname = dbnames[i]
;        pfname = pfnames[i]
;        
;        stplot_calc_pflux_mat, dename, dbname, pfname, $
;            filter = tfilters, scaleinfo = sclinfo
;            
;        vars = [dename,dbname,pfname]+'_mat'
;        options, tvar, 'constant', 0
;        
;        ; map poynting flux.
;        vars = pfname+[suffixs,'_mat']
;        for j = 0, n_elements(vars)-1 do begin
;            tvar = vars[j]
;            get_data, pre0+'b0_gse', t0, dat
;            store_data, pre0+'b0', t0, sqrt(total(dat^2,2))
;            smap2iono, tvar, pre0+'fpt_mlat', b = pre0+'b0', $
;                newname = tvar+'_map', coef = coef
;            tvar = vars[j]+'_map'
;            options, tvar, 'constant', 0
;            options, tvar, 'colors', rgb
;        endfor
;        store_data, pre0+'map_coef', t0, coef
;    endfor

stop



    
; **** save data to disk.
    ofn = datadir+'/psbl_de_32hz_data_'+id+'.tplot'
    tplot_save, datavar, filename = ofn
    
end


idinfos = psbl_de_id('detect_step')
nidinfo = n_elements(idinfos)

for i = 0, nidinfo-1 do begin
    
    tinfo = idinfos[i]
    id = tinfo.id
    utr = tinfo.utr
    
    store_data, '*', /delete
    psbl_de_plot_32hz_data, id, trange = utr, rootdir = rootdir
endfor

end
