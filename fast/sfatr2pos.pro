;+
; Type: procedure.
; Purpose:
;       Use the orbit-based time range to generate date-based position file,
;   with file name pattern of fa_or_def_yyyymmdd_v*.cdf. The info are:
;   mlt, ilat, altitude, orbit that can be got from get_fa_orbit.
;   Supposed to be run only one time.
; Parameters:
;   orbs, in, lonarr[2], opt. Orbit ranges. Default is [330,51315], 
;       that's when fast has esa data.
;   orbfile, in, string, opt. File with orbit's info & start/end epoch, e.g.,
;       8833    1998-11
;       The file is generated by swfaorbtr.
; Keywords: none.
; Notes:
;   * The output file has pattern 'fa_or_def_yyyymmdd_v01.cdf'. The vars are:
;       'Epoch': epoch of data.
;       'ilat': invariant latitude in radian, has sign.
;       'mlt': magnetic local time in hour.
;       'alt': altitude in km.
;       'orbit': orbit number.
;       'pos_gse': fast position in GSE coord.
; Dependence: none.
; History:
;   2013-04-09, Sheng Tian, create.
;-
pro sfatr2pos, orbs, ifn

    compile_opt idl2

    if n_elements(orbs) eq 0 then orbs = [330,51315ul]

    ofndir = '~/works/data/fast/orbit/'
    if ~file_test(ofndir, /directory) then file_mkdir, ofndir

    if n_elements(ifn) eq 0 then ifn = '~/works/data/fast/orbit/fa_orb_tr.dat'

    ; find the first orbit's line.
    torb = 0L
    tep1 = ''
    tep2 = ''
    openr, lun, ifn, /get_lun
    term = -1       ; lun of terminal.
    while ~eof(lun) do begin
        readf, lun, torb, tep1, tep2, format = '(I05, 4X, A23, 4X, A23)'
        printf, term, 'reading orbit ', torb
        ; get time and position.
        t1 = floor(time_double(tep1)/60)
        t2 = ceil(time_double(tep2)/60)
        nrec = t2-t1+1
        if nrec le 10 then continue
        if torb ge orbs[0] then break   ; torb may be larger than orbs[0].
    endwhile
    if eof(lun) then return             ; end of file.
    t0 = (t1+dindgen(nrec))*60D
    print, time_string([t0[0],t0[nrec-1]], /sql)
    tval = t0
    get_fa_orbit, tval, nrec, struc = data, $
        /time_array, /no_store, /definitive
    ; save data.
    time = t0
    ilat = data.ilat
    mlt = data.mlt
    alt = data.alt
    pos = data.fa_pos
    orb = data.orbit
    dayt2 = (floor(time[0]/86400d)+1)*86400d     ; unix time of next day.

    ; loop through each orbit.
    while torb le orbs[1] do begin
        readf, lun, torb, tep1, tep2, format = '(I05, 4X, A23, 4X, A23)'
        printf, term, 'reading orbit ', torb
        ; get time and position.
        t1 = round(time_double(tep1)/60)
        t2 = round(time_double(tep2)/60)
        nrec = t2-t1+1
        if nrec le 10 then continue     ; >10 min, see orb 00332, 1 min data.
        t0 = (t1+dindgen(nrec))*60D
        print, time_string([t0[0],t0[nrec-1]], /sql)
        tval = t0
        get_fa_orbit, tval, nrec, struc = data, $
            /time_array, /no_store, /definitive
        if t0[0] le dayt2 then begin    ; still in the day.
            ; merge new data to data of the day.
            time = [time, t0]
            ilat = [ilat, data.ilat]
            mlt = [mlt, data.mlt]
            alt = [alt, data.alt]
            pos = [pos, data.fa_pos]
            orb = [orb, data.orbit]
        endif else begin            ; start a new day.
            ; write data of the day to file.
            ofn = ofndir+'fa_or_def_'+$
                time_string(time[0], format = 2, /date_only)+'_v01.cdf'
            printf, term, 'write to file: '+ofn+' ...'
            cdfid = cdf_create(ofn)
            ; need truncate?
            flag = where(time ge dayt2)
            idx = (flag[0] eq -1)? n_elements(time)-1: flag[0]
            ; check uniqness (see orbit 1983 and 1984, 21:16 UT).
            idx0 = uniq(time[0:idx])
            ; write epoch.
            vname = 'time'
            tval = time[idx0]
            varid = cdf_varcreate(cdfid, vname, /zvariable, /cdf_epoch)
            cdf_varput, cdfid, vname, tval
            ; write ilat.
            vname = 'ilat'
            tval = ilat[idx0]
            varid = cdf_varcreate(cdfid, vname, /zvariable)
            cdf_varput, cdfid, vname, tval
            ; write mlt.
            vname = 'mlt'
            tval = mlt[idx0]
            varid = cdf_varcreate(cdfid, vname, /zvariable)
            cdf_varput, cdfid, vname, tval
            ; write alt.
            vname = 'alt'
            tval = alt[idx0]
            varid = cdf_varcreate(cdfid, vname, /zvariable)
            cdf_varput, cdfid, vname, tval
            ; write pos.
            vname = 'pos_gse'
            tval = pos[idx0,*]
            varid = cdf_varcreate(cdfid, vname, [1,1], $
                dimensions = size(tval, /dimensions), /zvariable)
            cdf_varput, cdfid, vname, tval
            ; write orb.
            vname = 'orbit'
            tval = orb[idx0]
            varid = cdf_varcreate(cdfid, vname, /zvariable)
            cdf_varput, cdfid, vname, tval
            ; finish and close.
            cdf_close, cdfid
            ; save data.
            if flag[0] eq -1 then begin
                time = t0
                ilat = data.ilat
                mlt = data.mlt
                alt = data.alt
                pos = data.fa_pos
                orb = data.orbit
            endif else begin
                time = [time[idx:*],t0]
                ilat = [ilat[idx:*],data.ilat]
                mlt = [mlt[idx:*],data.mlt]
                alt = [alt[idx:*],data.alt]
                pos = [pos[idx:*,*],data.fa_pos]
                orb = [orb[idx:*],data.orbit]
            endelse
            dayt2 = (floor(time[0]/86400d)+1)*86400d
        endelse
    endwhile
    free_lun, lun
end
