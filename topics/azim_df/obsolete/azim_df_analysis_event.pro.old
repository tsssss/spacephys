;+
; Event-based programs. Load basic data and do analysis:
;   1.
;
; Add event_id to project as a general handler.
;-

pro azim_df_analysis_event, event_time_range, event_id=event_id, project=project, reset=reset, sort_mlt_as_is=sort_mlt_as_is

    if n_elements(project) eq 0 then project = azim_df_load_project()
    if n_elements(event_time_range) ne 2 then begin
        errmsg = handle_error('No input event_time_range ...')
        return
    endif
    candidates = project.candidate
    foreach candidate, candidates do begin
        full_time_range = candidate.time_range
        if max(event_time_range) lt min(full_time_range) then continue
        if min(event_time_range) gt max(full_time_range) then continue
        event_id = candidate.id
        break
    endforeach

    ; Check if it is a themis-only event.
    if n_elements(event_id) eq 0 then begin
        the_key = 'themis_candidates'
        if ~project.haskey(the_key) then begin
            project[the_key] = hash()
            themis_candidates = project[the_key]

            ; Events.
            probes = 'th'+letters('e')
            events = list()
            events.add, time_double(['2008-02-04/02:00','2008-02-04/22:00'])
            events.add, time_double(['2008-02-29/02:00','2008-02-29/22:00'])
            foreach time_range, events do begin
                event_id = time_string(mean(time_range),tformat='YYYY_MMDD_hh')
                themis_candidates[event_id] = dictionary($
                    'id', event_id, $
                    'available_probes', probes, $
                    'time_range', time_range, $
                    'data_file_suffix', event_id+'_data.tplot')
            endforeach
        endif

        candidates = project[the_key]
        foreach candidate, candidates do begin
            full_time_range = candidate.time_range
            if max(event_time_range) lt min(full_time_range) then continue
            if min(event_time_range) gt max(full_time_range) then continue
            event_id = candidate.id
            break
        endforeach
    endif

    if n_elements(event_id) eq 0 then begin
        errmsg = handle_error('No input time_range or event_id ...')
        return
    endif
    candidate = candidates[event_id]
    full_time_range = candidate.time_range

test = 1

;---Load basic data and event_info.
    azim_df_load_basic_data, full_time_range, event_id=event_id, project=project, reset=reset, data_file=data_file
    event_infos = azim_df_load_event_info(project=project, reset=1)
    if ~event_infos.haskey(event_id) then begin
        errmsg = handle_error('Cannot find event_id: '+event_id+' ...')
        return
    endif
    event_info = get_var_data('event_info')
    save_vars = tnames('*')
    the_info = event_infos[event_id]
    if n_elements(event_time_range) ne 2 then event_time_range = the_info.time_range


;---Get common_times.
    time_step = project.time_step
    common_times = make_bins(event_time_range, time_step)
    ntime = n_elements(common_times)


;---Determine which side of the midnight.
    ref_time = the_info.ref_time
    post_midn_triad_flag = get_var_data('post_midn_triad_flag', at=ref_time)
    pre_midn_triad_flag = get_var_data('pre_midn_triad_flag', at=ref_time)
    midn_flag = (post_midn_triad_flag gt pre_midn_triad_flag)? 'post': 'pre'
    if event_id eq '2008_0204_12' then midn_flag = 'post'
    event_info['midn_flag'] = midn_flag


;---Find the probes.
    mission_probes = the_info.mission_probes
    nprobe = n_elements(mission_probes)
    if nprobe eq 0 then begin
        available_probes = event_info.available_probes
        navailable_probe = n_elements(available_probes)
        data_flags = get_var_data(midn_flag+'_midn_data_flag', in=event_time_range)
        nflags = total(data_flags, 1)
        index = where(nflags eq ntime, nprobe)
        if nprobe eq 0 then begin
            errmsg = handle_error('No available probe ...')
            return
        endif
        mission_probes = available_probes[index]
    endif
    event_info['mission_probes'] = mission_probes

    ; Sort probes by MLT.
    mean_time = mean(event_time_range)
    mean_mlts = list()
    foreach probe, mission_probes do mean_mlts.add, get_var_data(probe+'_mlt', at=mean_time)
    mean_mlts = mean_mlts.toarray()
    sorted_probes = mission_probes[sort(abs(mean_mlts))]    ; closest to the midnight comes first.
    if keyword_set(sort_mlt_as_is) then sorted_probes = mission_probes[sort(mean_mlts)]
    event_info['sorted_probes'] = sorted_probes


;---Calculate time lag.
    lprmsg, 'Perform x-corr for '+event_id+' ...'
    str_pm = '!9'+string(177b)+'!X'
    cc_time_range = the_info.cc_time_range
    cc_info = hash()
    shift_limit = the_info.cc_time_lag*60.
    shift_ratio = 0.3
    if event_id eq '2008_0229_12' then shift_ratio = 0.5
    shifts = smkarthm(-shift_limit*shift_ratio, shift_limit*(1-shift_ratio), time_step, 'dx')
    nshift = n_elements(shifts)
    lags = round(shifts/time_step)
    foreach probe, sorted_probes, ii do begin
        cc_info[probe] = dictionary()
        if ii eq 0 then begin
            cc_info[probe].time_lag = 0.
            cc_info[probe].max_corr = 0.
            running_time_range = cc_time_range
            cc_info[probe].time_lag_error = 0.
        endif else begin
            running_time_range += cc_info[sorted_probes[ii-1]].time_lag

        ;---Need to be very very very careful to line f0s and f1s up to the same time tag.
            get_data, sorted_probes[ii-1]+'_theta_sector', uts, f0s
            x0s = round((uts-event_time_range[0])/time_step)
            nx0 = n_elements(x0s)
            get_data, sorted_probes[ii]+'_theta', uts, f1s
            index = lazy_where(uts, event_time_range)
            uts = uts[index]
            f1s = f1s[index]
            x1s = round((uts-event_time_range[0])/time_step)
            nx1 = n_elements(x1s)
            corr_2d = fltarr(nshift)
            ; Calculate the new time.
            for kk=0, nshift-1 do begin
                index = x0s[0]+lags[kk]
                if index lt 0 then continue
                if index+nx0 ge nx1 then continue
                tf1 = f1s[index:index+nx0-1]
                corr_2d[kk] = c_correlate(tf1,f0s,0)
            endfor
            max_corr = max(corr_2d)
            index = where(corr_2d eq max_corr)
            the_shift = shifts[index[0]]

            ; Apply shift.
            get_data, sorted_probes[ii-1]+'_theta_sector', uts, f0s, limits=lim
            uts += the_shift
            cc_info[probe].time_lag = the_shift
            cc_info[probe].max_corr = max_corr
            store_data, sorted_probes[ii-1]+'_theta_sector', uts, f0s, limits=lim

            ; Error in the time lag (The cluster book, Equation 1.7)
            xxs = x0s
            del_x = xxs-mean(xxs)
            dx_dt = deriv(xxs)/time_step
            mm = n_elements(xxs)
            time_lag_error = sqrt(1./(mm-1)*(1-max_corr)/max_corr*2*mean(del_x^2)/mean(dx_dt^2))
            cc_info[probe].time_lag_error = time_lag_error

            file = join_path([project.plot_dir,'cross_corr','fig_'+event_id+'_calc_cross_corr_'+strjoin(sorted_probes[ii-1:ii],'_')+'.pdf'])
            if keyword_set(test) then file = test+ii-1
            sgopen, file, xsize=5, ysize=6, /inch
            poss = sgcalcpos(4, xchsz=xchsz, ychsz=ychsz, tmargin=4, bmargin=10, rmargin=8)

            options, sorted_probes[ii-1]+'_theta', 'labels', strupcase(sorted_probes[ii-1])
            options, sorted_probes[ii-1]+'_theta_sector', 'labels', strupcase(sorted_probes[ii-1])+'!C  shifted'
            options, sorted_probes[ii]+'_theta', 'labels', strupcase(sorted_probes[ii])

            tpos = poss[*,0:2]
            vars = [sorted_probes[ii-1]+'_theta'+['','_sector'], sorted_probes[ii]+'_theta']
            options, vars, 'xticklen', -0.02
            tplot, vars, /novtitle, $
                trange=event_time_range, position=tpos

            ; Add labels.
            tpos = poss[*,0]
            tx = tpos[0]
            ty = tpos[3]+ychsz*0.5
            xyouts, tx,ty, /normal, event_id+', cross.corr.'
            tpos = poss[*,1]
            tx = tpos[0]+xchsz*1
            ty = tpos[3]-ychsz*1
            xyouts, tx,ty, /normal, 'dt = '+string(the_shift,format='(I0)')+' sec'

            tpos = poss[*,0]
            plot, event_time_range, [0,1], /nodata, /noerase, xstyle=5, ystyle=5, position=tpos
            tmp = convert_coord(running_time_range[0],0, /data, /to_normal)
            tx1 = tmp[0]
            tmp = convert_coord(running_time_range[1],0, /data, /to_normal)
            tx2 = tmp[0]
            ty = tpos[1]+ychsz*0.5
            plots, [tx1,tx2], [0,0]+ty, /normal
            plots, tx1+[0,0], ty+[-1,1]*ychsz*0.2, /normal
            plots, tx2+[0,0], ty+[-1,1]*ychsz*0.2, /normal
            xyouts, (tx1+tx2)*0.5, ty+ychsz*0.2, /normal, 'data for c.c.', alignment=0.5


            ; Add cc plot.
            tpos = poss[*,3]-[0,1,0,1]*ychsz*5
            xtitle = 'dt (sec)'
            xrange = minmax(shifts)
            ytitle = 'c.c. (#)'
            yrange = [0,1]
            plot, shifts, corr_2d, position=tpos, $
                xstyle=1, xtitle=xtitle, xrange=xrange, xticklen=-0.02, $
                ystyle=1, ytitle=ytitle, yrange=yrange, yticklen=-0.01, $
                /noerase
            plots, the_shift+[0,0], yrange, linestyle=1
            plots, the_shift+[-1,1]*time_lag_error, mean(yrange)+[0,0]
            foreach tx, [-1,1] do plots, the_shift+tx*time_lag_error, mean(yrange)+[-1,1]*0.03
            tx = tpos[0]
            ty = tpos[3]+ychsz*0.5
            xyouts, tx,ty,/normal, $
                'max c.c. = '+string(max_corr,format='(F5.2)')+', dt = '+string(the_shift,format='(I0)')+$
                str_pm+string(time_lag_error,format='(I0)')+' sec'

            ;if keyword_set(test) then stop
            sgclose
        endelse

        var = probe+'_theta'
        get_data, var, uts, dat, limits=lim
        index = lazy_where(uts, '[]', running_time_range+cc_info[probe].time_lag)
        store_data, var+'_sector', uts[index], dat[index], limits=lim
        cc_info[probe].var = probe+'_theta_sector'
    endforeach
    event_info['cc_info'] = cc_info

    ; Save results.
    time_lags = fltarr(nprobe)
    foreach probe, sorted_probes, ii do begin
        time_lags[ii:*] -= cc_info[probe].time_lag
        get_data, probe+'_theta', uts, dat, limits=lim
        store_data, probe+'_theta_new', uts+time_lags[ii], dat, limits=lim
    endforeach


;---Get arrival_time and the associated position.
    tilt = get_var_data(sorted_probes[0]+'_theta', at=common_times)
    max_val = max(tilt, max_id)
    min_val = min(tilt[0:max_id], min_id)
    del_val = 0.25*(max_val-min_val)
    mean_val = 0.5*(max_val+min_val)
    half_min_val = mean_val-del_val
    index = where(tilt gt half_min_val)
    min_id = index[0]
    half_max_val = mean_val+del_val
    index = where(tilt gt half_max_val)
    max_id = index[0]
    tilt = tilt[min_id:max_id]
    uts = common_times[min_id:max_id]
    index = where(tilt le half_min_val)
    min_time = uts[index[-1]]
    index = where(tilt ge half_max_val and uts gt min_time)
    max_time = uts[index[0]]
    arrival_time0 = mean([min_time,max_time])
    foreach probe, sorted_probes, ii do begin
        if ~event_info.haskey(probe) then event_info[probe] = dictionary()
        probe_info = event_info[probe]
        time_lag0 = (ii eq 0)? 0: event_info[sorted_probes[ii-1]].time_lag
        time_lag = time_lag0+cc_info[probe].time_lag
        probe_info.time_lag = time_lag
        arrival_time = arrival_time0+time_lag
        probe_info.arrival_time = arrival_time
        probe_info.arrival_mlt = get_var_data(probe+'_mlt', at=arrival_time)
        probe_info.arrival_rsm = get_var_data(probe+'_r_sm', at=arrival_time)
        probe_info.arrival_mlat = get_var_data(probe+'_mlat', at=arrival_time)
    endforeach

    arrival_mlts = fltarr(nprobe)
    foreach probe, sorted_probes, ii do arrival_mlts[ii] = event_info[probe].arrival_mlt
    index = sort(abs(arrival_mlts))
    sorted_probes = sorted_probes[index]
    event_info['sorted_probes'] = sorted_probes
    event_info['cc_info'] = cc_info

    ; Get the temporal scale of the gradient of each probe.
    foreach probe, sorted_probes, ii do begin
        probe_info = event_info[probe]
        tilt = get_var_data(sorted_probes[0]+'_theta', at=common_times)
        max_val = max(tilt, max_id)
        min_val = min(tilt[0:max_id], min_id)
        del_val = 0.25*(max_val-min_val)
        mean_val = 0.5*(max_val+min_val)
        half_min_val = mean_val-del_val
        half_max_val = mean_val+del_val
        tilt = tilt[min_id:max_id]
        uts = common_times[min_id:max_id]
        index = where(tilt le half_min_val)
        min_time = uts[index[-1]]
        index = where(tilt ge half_max_val and uts gt min_time)
        max_time = uts[index[0]]
        probe_info['gradient_time_range'] = [min_time,max_time]
        probe_info['gradient_temporal_scale'] = max_time-min_time
    endforeach


;---Plot the data before/after time lags are removed.
    if keyword_set(test) then begin
        stop
        foreach probe, sorted_probes, ii do if ii ne 0 then wdelete, test+ii-1
    endif
    file = join_path([project.plot_dir,'cross_corr','fig_'+event_id+'_after_time_lag_removed.pdf'])
    if keyword_set(test) then file = test
    sgopen, file, xsize=5, ysize=6
    tplot, sorted_probes+'_theta_new', trange=event_time_range
    timebar, arrival_time0, linestyle=1
    sgclose

    file = join_path([project.plot_dir,'cross_corr','fig_'+event_id+'_before_time_lag_removed.pdf'])
    if keyword_set(test) then file = test+1
    sgopen, file, xsize=5, ysize=6
    tplot, sorted_probes+'_theta', trange=event_time_range
    timebar, arrival_time0, linestyle=1
    if keyword_set(test) then stop
    sgclose


;---Do linear fit.
    nprobe = n_elements(sorted_probes)
    arrival_times = dblarr(nprobe)
    arrival_mlts = fltarr(nprobe)
    foreach probe, sorted_probes, ii do begin
        arrival_times[ii] = event_info[probe].arrival_time
        arrival_mlts[ii] = event_info[probe].arrival_mlt
    endforeach
    linfit_info = dictionary()
    fit_result = linfit(arrival_times, arrival_mlts, yfit=yfit, sigma=sigma)
    omega = fit_result[1]*15*60 ; in deg/min.
    linfit_info['omega'] = omega
    r_square = 1-total((arrival_mlts-yfit)^2)/total((arrival_mlts-mean(arrival_mlts))^2)
    linfit_info['r_square'] = r_square
    linfit_info['fit_result'] = fit_result
    linfit_info['sigma'] = sigma
    event_info['linfit_info'] = linfit_info



;---Calculate the 2D velocities for all combo.
; All combos saved in timing_info.
    lprmsg, 'Perform 3-spacecraft timing for '+event_id+' ...'
    deg = 180d/!dpi
    rad = !dpi/180d
    re = 6378d
    the_key = 'km_s2deg_min'
    if ~project.haskey(the_key) then project[the_key] = 1/re*deg*60
    km_s2deg_min = project[the_key]

    nsc4timing = 3
    ndim = 3
    dim_index = [0,1]   ; 2-d plane, the SM x-y plane.
    arrival_times = dblarr(nsc4timing)
    arrival_rsms = fltarr(ndim,nsc4timing)
    timing_info = dictionary()
    probe_combos = choose_from(sorted_probes, nsc4timing)
    foreach probes, probe_combos do begin
        probe_combo = strjoin(probes[sort(probes)],'_')
        foreach probe, probes, ii do begin
            arrival_times[ii] = event_info[probe].arrival_time
            arrival_rsms[*,ii] = event_info[probe].arrival_rsm
        endforeach
        rsm_center = total(arrival_rsms,2)/nsc4timing

        ; Sort by arrival_time
        index = sort(arrival_times)
        arrival_times = arrival_times[index]
        arrival_rsms = arrival_rsms[*,index]
        probes = probes[index]

        ; Solve for timing.
        tt = arrival_times[1:nsc4timing-1]-arrival_times[0]
        rr = fltarr(ndim,nsc4timing-1)
        for ii=0, nsc4timing-2 do rr[*,ii] = arrival_rsms[*,ii+1]-arrival_rsms[*,0]
        rr = rr[dim_index,*]
        vv = la_linear_equation(rr,tt)
        v_hat = sunitvec(vv)
        rr_normal = dblarr(nsc4timing-1)
        for ii=0, nsc4timing-2 do rr_normal[ii] = sdot(rr[*,ii],v_hat)
        fit_result = linfit(tt, rr_normal)
        v_mag = fit_result[1]*re
        rxy_center = [rsm_center[dim_index],0]
        omega = snorm(vec_cross([v_hat,0],sunitvec(rxy_center)))*v_mag/snorm(rxy_center)*km_s2deg_min
        triangle_angles = [$
            sang(rr[*,0],rr[*,1]        ,/degree), $
            sang(rr[*,0],rr[*,1]-rr[*,0],/degree), $
            sang(rr[*,1],rr[*,0]-rr[*,1],/degree)]
        time_diffs = abs([$
            arrival_times[0]-arrival_times[1], $
            arrival_times[1]-arrival_times[2], $
            arrival_times[2]-arrival_times[0]])
        ; All quantities are in the same ordering.
        combo_info = dictionary($
            'combo', probe_combo, $
            'probes', probes, $
            'times', arrival_times, $
            'rsms', arrival_rsms, $
            'rsm_center', rsm_center, $
            'v_mag', v_mag, $
            'v_hat', v_hat, $
            'omega', omega, $
            'time_diffs', time_diffs, $
            'triangle_angles', triangle_angles)
        timing_info[probe_combo] = combo_info
    endforeach
    event_info['timing_info'] = timing_info



;---Filter out the good combo.
; Goog combos saved in good_combo_info.
    lprmsg, 'Filter good triad for '+event_id+' ...'
    triad_angle_range = project.triad_angle_range
    the_key = 'triad_time_diff_limit'
    if ~project.haskey(the_key) then project[the_key] = 120.
    triad_time_diff_limit = project[the_key]

    ; Flags: 1 for good combo.
    flags = list()
    combo_probes = list()
    ndim = 3
    foreach probe_combo, timing_info.keys() do begin
        the_flag = 1
        combo_info = timing_info[probe_combo]
        triangle_angles = combo_info.triangle_angles
        index = lazy_where(triangle_angles, '[]', triad_angle_range, count=count)
        if count ne ndim then the_flag = 0
        time_diffs = combo_info.time_diffs
        index = where(time_diffs ge triad_time_diff_limit, count)
        if count ne ndim then the_flag = 0
        combo_info['flag'] = the_flag
        if the_flag eq 1 then combo_probes.add, strsplit(probe_combo,'_',/extract), /extract
    endforeach

    ; combo_probes.
    good_combo_info = dictionary()
    if n_elements(combo_probes) ne 0 then begin
        combo_probes = sort_uniq(combo_probes.toarray())
        good_combo_info['combo_probes'] = combo_probes
        nprobe = n_elements(combo_probes)
        mlts = fltarr(nprobe)
        diss = fltarr(nprobe)
        mlats = fltarr(nprobe)
        foreach probe, combo_probes, ii do begin
            mlts[ii] = event_info[probe].arrival_mlt
            mlats[ii] = event_info[probe].arrival_mlat
            diss[ii] = snorm(event_info[probe].arrival_rsm)
        endforeach
        good_combo_info['mlt_range'] = minmax(mlts)
        good_combo_info['dis_range'] = minmax(diss)
        good_combo_info['mlat_range'] = minmax(mlats)
    endif
    event_info['good_combo_info'] = good_combo_info


;---Make a plot for all triangles, good and bad.
    dis_scale = 2.  ; Re
    vel_scale = 20. ; km/s
    bad_triad_color = sgcolor('red')
    good_triad_color = sgcolor('blue')
    black = sgcolor('black')
    label_size = 0.7
    probe_combos = timing_info.keys()
    nprobe_combo = n_elements(probe_combos)
    label_letters = letters(nprobe_combo)
    nxpanel = 5.
    nypanel = ceil(nprobe_combo/nxpanel)
    xy_range = [5,-20]  ; sun to the left.
    panel_xrange = xy_range
    panel_yrange = (midn_flag eq 'post')? xy_range: -reverse(xy_range)
    panel_xsize = 2
    panel_ysize = panel_xsize*abs(total(panel_yrange*[-1,1])/total(panel_xrange*[-1,1]))
    sgopen, 0, xsize=panel_xsize, ysize=panel_ysize, /inch
    tmp = sgcalcpos(1, xchsz=xchsz, ychsz=ychsz, position=[0,0,1,1])
    sgclose, /wdelete
    margins = [7.,5,2,1]
    xpad = 1*ychsz/xchsz
    ypad = 1
    fig_xsize = panel_xsize*nxpanel+(xpad*(nxpanel-1)+(margins[0]+margins[2]))*xchsz*panel_xsize
    fig_ysize = panel_ysize*nypanel+(ypad*(nypanel-1)+(margins[1]+margins[3]))*ychsz*panel_ysize

    if keyword_set(test) then begin
        file = test
        magnify = 1
        hsize = 2
    endif else begin
        file = join_path([project.plot_dir,'triangle_collage','fig_'+event_id+'_triangle_collage.pdf'])
        magnify = 1
        hsize = 160
    endelse

    sgopen, file, xsize=fig_xsize, ysize=fig_ysize, magnify=magnify, /inch
    panel_poss = sgcalcpos(nypanel,nxpanel, xpad=xpad, ypad=ypad, margins=margins, xchsz=xchsz, ychsz=ychsz)

    ; Treat each combo.
    foreach probe_combo, probe_combos, panel_id do begin
        combo_info = timing_info[probe_combo]
        probes = combo_info.probes
        arrival_times = combo_info.times
        rsms = combo_info.rsms
        rsm_center = combo_info.rsm_center
        v_mag = combo_info.v_mag
        v_hat = combo_info.v_hat

        index = array_indices([nxpanel,nypanel], panel_id, /dimensions)
        tpos = panel_poss[*,index[0],index[1]]
        xtitle = (index[1] eq nypanel-1)? 'SM X (Re)': ''
        ytitle = (index[0] eq 0)? 'SM Y (Re)': ''
        xtickformat = (index[1] eq nypanel-1)? '(I0)': '(A1)'
        ytickformat = (index[0] eq 0)? '(I0)': '(A1)'
        plot, panel_xrange, panel_yrange, xstyle=1, ystyle=1, position=tpos, $
            xrange=panel_xrange, yrange=panel_yrange, /nodata, /noerase, /isotropic, $
            xtitle=xtitle, ytitle=ytitle, xticklen=-0.01, yticklen=-0.01, xtickformat=xtickformat, ytickformat=ytickformat

        ; Add scale.
        if panel_id eq 0 then begin
            tx = tpos[2]-xchsz*2
            ty = tpos[3]-ychsz*2.3
            tmp = convert_coord(tx,ty, /normal, /to_data)
            tmp = convert_coord(tmp[0]-dis_scale,tmp[1], /data, /to_normal)
            dx = abs(tmp[0]-tx)
            xs = tx+[-1,1]*0.5*dx
            plots, xs, ty+[0,0], /normal
            foreach tx, xs do plots, tx+[0,0], ty+[-1,1]*ychsz*0.1, /normal
            tx = mean(xs)
            ty = tpos[3]-ychsz*2
            xyouts, tx,ty,/normal, alignment=0.5, sgnum2str(vel_scale)+' km/s', charsize=label_size
        endif

        ; Add figure label.
        tx = tpos[2]-xchsz*2
        ty = tpos[3]-ychsz*1
        label = +'('+sgnum2str(index[1]+1)+'-'+sgnum2str(index[0]+1)+')'
        xyouts, tx,ty,/normal,alignment=0.5, label

        ; Add geometry and timing criteria, add flag.
        good_combo = combo_info.flag
        msg = (good_combo eq 1)? 'Good': 'Bad'
        triad_color = good_combo? good_triad_color: bad_triad_color
        msg = msg+' triad'
        tx = tpos[2]-xchsz*1
        ty = tpos[1]+ychsz*0.5
        xyouts, tx,ty,/normal,alignment=1, msg, color=triad_color, charsize=large_size

        ; Add earth.
        tmp = 50
        tmp = findgen(tmp)/(tmp-1)*2*!dpi
        xs = cos(tmp)
        ys = sin(tmp)
        polyfill, xs<0, ys, /line_fill, orientation=45, spacing=ychsz*5
        plots, xs, ys
        foreach r, make_bins(minmax(abs(xy_range)),5,/inner) do oplot, xs*r, ys*r, linestyle=1

        ; Add spacecraft and labels.
        for ii=0, nsc4timing-1 do begin
            tx = rsms[dim_index[0],ii]
            ty = rsms[dim_index[1],ii]
            plots, tx,ty, psym=6, symsize=label_size*0.5
            probe_info = resolve_probe(probes[ii])
            short_name = probe_info.short_name
            xyouts, tx,ty,/data, '  '+strupcase(short_name), charsize=label_size
        endfor

        ; Add triangle.
        tx = rsms[dim_index[0],*]
        ty = rsms[dim_index[1],*]
        for ii=0, nprobe-1 do begin
            plots, (shift(tx,ii))[0:1], (shift(ty,ii))[0:1], linestyle=1
        endfor

        ; Add arrow.
        x0 = mean(rsms[dim_index[0],*])
        y0 = mean(rsms[dim_index[1],*])
        scale = dis_scale/vel_scale*v_mag
        x1 = x0+v_hat[0]*scale
        y1 = y0+v_hat[1]*scale
        arrow, x0,y0,x1,y1,/data, /solid, hsize=hsize

        tx = tpos[0]+xchsz*1
        triangles = combo_info.triangle_angles
        triangles = triangles[sort(triangles)]
        ty = tpos[3]-ychsz*1
        xyouts, tx,ty, /normal, 'Triad (deg):', charsize=label_size
        foreach triangle, triangles, jj do begin
            msg = strtrim(string(triangle,format='(F5.1)'),2)
            if jj ne 2 then msg += ','
            index = lazy_where(triangle, '][', triad_angle_range, count=count)
            color = (count ne 0)? bad_triad_color: black
            ttx = tx+(6+3*jj)*xchsz
            xyouts, ttx,ty,/normal, msg, charsize=label_size, color=color
        endforeach


        ; Add time info.
        ty = tpos[3]-ychsz*2
        time_diffs = combo_info.time_diffs
        time_diffs = time_diffs[sort(time_diffs)]
        xyouts, tx,ty, /normal, 'T.diff (sec):', charsize=label_size
        foreach time_diff, time_diffs, jj do begin
            msg = strtrim(string(round(time_diff),format='(I0)'),2)
            if jj ne 2 then msg += ','
            color = (time_diff lt triad_time_diff_limit)? bad_triad_color: black
            ttx = tx+(6+3*jj)*xchsz
            xyouts, ttx,ty,/normal, msg, charsize=label_size, color=color
        endforeach


        ; Add velocity info.
        ty = tpos[3]-ychsz*3
        xyouts, tx,ty, /normal, charsize=label_size, '|V| = '+string(v_mag,format='(F5.1)')+' km/s'
        omega = combo_info.omega
        xyouts, tx+xchsz*9,ty, /normal, charsize=label_size, '|'+tex2str('omega')+'| = '+string(omega,format='(F5.1)')+' deg/min'

        if keyword_set(test) then stop
    endforeach

    if keyword_set(test) then stop
    sgclose



    tplot_save, save_vars, filename=data_file
    azim_df_plot_time_lag, event_time_range, project=project
    if keyword_set(test) then stop

end

time_range = time_double(['2014-08-28/09:30','2014-08-28/11:30'])
sort_mlt_as_is = 0
;time_range = time_double(['2017-03-28/02:00','2017-03-28/05:00'])
time_range = time_double(['2008-02-04/14:00','2008-02-04/17:00'])
sort_mlt_as_is = 1
;time_range = time_double(['2008-02-29/08:00','2008-02-29/09:30'])
;sort_mlt_as_is = 0
azim_df_analysis_event, time_range, project=project, sort_mlt_as_is=sort_mlt_as_is
end
