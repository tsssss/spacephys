;+
; Search for candidates by search for storms, then select storms with apogee_search, then select candidate with triad_search.
; Write settings to project, and write results to a text file.
;-

pro azim_df_search_candidate_search_storm_diagnostic_plot, project=project, time_range=time_range, file=plot_file
    ; Internal, do not check input.

    test = 0

;---Figure out the size of the plot.
    fig_ysize = 3.
    fig_aspect_ratio = 1.5   ; inch per day.
    secofday = constant('secofday')
    duration = total(time_range*[-1,1])/secofday
    fig_xsize = fig_ysize*fig_aspect_ratio*duration
    if n_elements(plot_file) eq 0 then plot_file = 0
    if keyword_set(test) then plot_file = test
    sgopen, plot_file, xsize=fig_xsize, ysize=fig_ysize, /inch
    margins = [8.,5,2,2]
    tpos = sgcalcpos(1, margins=margins, xchsz=xchsz, ychsz=ychsz)


;---Get the data.
    the_var = 'dst'
    time_step = 60.
    xxs = make_bins(time_range, time_step)
    yys = get_var_data(the_var, at=xxs)

;---Get the settings for axes.
    xticklen_chsz = -0.15
    yticklen_chsz = -0.30

    ; y-axis.
    yticklen = yticklen_chsz*xchsz/(tpos[2]-tpos[0])
    ystep = 50.
    yrange = minmax(yys)
    ytickv = make_bins(yrange, ystep)
    yrange = minmax(ytickv)
    yticks = n_elements(ytickv)-1
    yminor = 5
    ytitle = '(nT)'

    ; x-axis.
    xticklen = xticklen_chsz*ychsz/(tpos[3]-tpos[1])
    xrange = time_range
    xminor = 8  ; hour.
    xstep = xminor*constant('secofhour')
    xtickv = make_bins(xrange, xstep, /inner) ; make time line up at hours.
    xticks = n_elements(xtickv)-1
    xtickn = strarr(xticks+1)
    for ii=0, xticks do begin
        the_time = xtickv[ii]
        xtickn[ii] = time_string(the_time,tformat='hh:mm')
        date = time_string(the_time,tformat='YYYY-MM-DD')
        if ii eq 0 then begin
            xtickn[ii] += '!C'+date
            continue
        endif
        if the_time mod secofday ne 0 then continue
        xtickn[ii] += '!C'+date
    endfor
    xtitle = ''

;---Set up coord.
    plot, xrange, yrange, $
        xstyle=5, xrange=xrange, xtickformat='(A1)', $
        ystyle=5, yrange=yrange, ytickformat='(A1)', $
        position=tpos, /noerase, /nodata
    oplot, xxs, yys

;---Add notations.
    settings = project.search_candidate.search_storm
    min_dst = settings.min_dst
    max_dst = settings.max_dst
    foreach ty, [max_dst,min_dst] do plots, xrange, ty+[0,0], linestyle=1
    times = xxs[where(yys le min_dst, count)]
    if count eq 0 then message, 'inconsistent result, stop ...'
    time_ranges = time_to_range(times, time_step=time_step)
    durations = time_ranges[*,1]-time_ranges[*,0]
    min_dst_duration = settings.min_dst_duration
    index = where(durations ge min_dst_duration, count)
    if count eq 0 then message, 'inconsistent result, stop ...'
    time_ranges = time_ranges[index,*]
    ntime_range = n_elements(time_ranges)/2
    min_dst_color = sgcolor('red')
    bar_thick = keyword_set(test)? 4: 8
    for ii=0, ntime_range-1 do begin
        the_time_range = reform(time_ranges[ii,*])
        plots, the_time_range, min_dst+[0,0], color=min_dst_color, thick=bar_thick
        tx = mean(the_time_range)
        ty = min_dst
        tmp = convert_coord(tx,ty, /data, /to_normal)
        tx = tmp[0]
        ty = tmp[1]+ychsz*constant('lineskip')
        duration = total(the_time_range*[-1,1])
        msg = sgnum2str(duration/constant('secofhour'),ndec=1)+' hr'
        xyouts, tx,ty,/normal,alignment=0.5, msg, color=min_dst_color, charsize=constant('label_size')
    endfor
    index = where(yys ge max_dst, count)
    if count eq 0 then message, 'inconsistent result, stop ...'


;---Add axes.
    plot, xrange, yrange, $
        xstyle=1, xrange=xrange, xtickv=xtickv, xticks=xticks, xminor=xminor, xtitle=xtitle, xticklen=xticklen, xtickname=xtickn, $
        ystyle=1, yrange=yrange, ytickv=ytickv, yticks=yticks, yminor=yminor, ytitle=ytitle, yticklen=yticklen, $
        position=tpos, /noerase, /nodata

;---Add labels.
    fig_label = 'a. Dst'
    tx = 1*xchsz
    ty = tpos[3]-ychsz*constant('full_ychsz')
    xyouts, tx,ty,/normal, fig_label

    duration = total(xrange*[-1,1])/secofday
    msg = 'Storm from '+strjoin(time_string(xrange,tformat='YYYY-MM-DD/hh:mm'), ' to ')+', duration is '+sgnum2str(duration,ndec=1)+' day(s)'
    tx = tpos[0]+xchsz*0
    ty = tpos[3]+ychsz*constant('lineskip')
    xyouts, tx,ty,/normal, msg

    if keyword_set(test) then stop
    sgclose

end

pro azim_df_search_candidate_search_storm, project=project
    ; Internal, do not check input.
    ; Search for storms.

    if project.done_search_candidate_search_storm then return
    lprmsg, 'Search candidate, search storm ...'
    overall_setting = project.search_candidate
    the_key = 'search_storm'
    if ~overall_setting.haskey(the_key) then overall_setting[the_key] = dictionary()
    settings = overall_setting[the_key]
    default_settings = dictionary($
        'time_range', time_double(['2012-10-01','2017-10-01']), $
        'min_dst', -50., $  ; nT.
        'min_dst_duration', 3600d, $    ; sec.
        'max_dst', 0., $    ; nT.
        'storm_pad_time', 0.5*constant('secofday'), $
        'file_suffix', 'azim_df_search_candidate_search_storm.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]

    lprmsg, 'Find storms from '+strjoin(time_string(settings.time_range),' to ')+' ...'
    storm_times = ts_load_storm_list(settings.time_range, $
        pad_time=settings.storm_pad_time, $
        min_value=settings.min_dst, min_duration=settings.min_dst_duration, $
        max_value=settings.max_dst)
    nstorm = n_elements(storm_times)/2

;---Save results, save diagnostic plots.
    lprmsg, 'Save diagnostic plots ...'
    for ii=0, nstorm-1 do begin
        time_range = reform(storm_times[ii,*])
        lprmsg, 'Processing storm from '+strjoin(time_string(time_range)+' to ')+' ...'
        plot_file = join_path([project.plot_dir,'diagnostic_plot','search_candidate','search_storm','storm_'+strjoin(time_string(time_range,tformat='YYYY_MMDD_hh'),'_')+'.pdf'])
        azim_df_search_candidate_search_storm_diagnostic_plot, project=project, time_range=time_range, file=plot_file
    endfor

    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    for ii=0, nstorm-1 do printf, lun, strjoin(time_string(reform(storm_times[ii,*]),tformat='YYYY-MM-DD/hh:mm'),' ')
    free_lun, lun

    lprmsg, 'Update project ...'
    settings.storm_times = storm_times
    project.done_search_candidate_search_storm = 1
    update_project, project

end



pro azim_df_search_candidate_search_apogee_diagnostic_plot, project=project, time_range=time_range, file=plot_file
    ; Internal, do not check input.

    test = 0

;---Figure out the size of the plot.
    margins = [9.,5,5,2]
    pans = [1,0.5,0.5]
    nypanel = n_elements(pans)
    panel_ypad = 0.5
    panel_ysize = 3
    panel_aspect_ratio = 1.5   ; inch per day.
    secofday = constant('secofday')
    duration = total(time_range*[-1,1])/secofday
    panel_xsize = panel_ysize*panel_aspect_ratio*duration
    sgopen, 0, xsize=1, ysize=1, /inch, xchsz=abs_xchsz,ychsz=abs_ychsz
    sgclose, /wdelete
    fig_xsize = panel_xsize+total(margins[[0,2]])*abs_xchsz
    fig_ysize = panel_ysize+total(margins[[1,3]])*abs_ychsz+panel_ypad*(nypanel-1)

    if n_elements(plot_file) eq 0 then plot_file = 0
    if keyword_set(test) then plot_file = test
    sgopen, plot_file, xsize=fig_xsize, ysize=fig_ysize, /inch
    pos = margins*[abs_xchsz,abs_ychsz,abs_xchsz,abs_ychsz]/[fig_xsize,fig_ysize,fig_xsize,fig_ysize]
    pos = [pos[0:1],1-pos[2:3]]
    poss = sgcalcpos(nypanel, position=pos, ypans=ypans, ypad=panel_ypad, xchsz=xchsz, ychsz=ychsz)


;---Common settings for x-axis.
    xticklen_chsz = -0.15
    yticklen_chsz = -0.30

    label_size = constant('label_size')
    half_ychsz = constant('half_ychsz')

    xrange = time_range
    xminor = 8  ; hour.
    xstep = xminor*constant('secofhour')
    xtickv = make_bins(xrange, xstep, /inner) ; make time line up at hours.
    xticks = n_elements(xtickv)-1
    xtickn = strarr(xticks+1)
    for ii=0, xticks do begin
        the_time = xtickv[ii]
        xtickn[ii] = time_string(the_time,tformat='hh:mm')
        date = time_string(the_time,tformat='YYYY-MM-DD')
        if ii eq 0 then begin
            xtickn[ii] += '!C'+date
            continue
        endif
        if the_time mod secofday ne 0 then continue
        xtickn[ii] += '!C'+date
    endfor
    xtitle = ''


;---Dst.
    tpos = poss[*,0]
    xticklen = xticklen_chsz*ychsz/(tpos[3]-tpos[1])
    xtickformat = '(A1)'
    if check_if_update('dst', time_range) then omni_read_index, time_range
    get_data, 'dst', xxs, yys
    index = where_pro(xxs, '[]', xrange)
    xxs = xxs[index]
    yys = yys[index]
    yticklen = yticklen_chsz*xchsz/(tpos[2]-tpos[0])
    ystep = 50.
    yrange = minmax(yys)
    ytickv = make_bins(yrange, ystep)
    yrange = minmax(ytickv)
    yticks = n_elements(ytickv)-1
    yminor = 5
    ytitle = '(nT)'

;---Set up coord.
    plot, xrange, yrange, $
        xstyle=5, xrange=xrange, xtickformat='(A1)', $
        ystyle=5, yrange=yrange, ytickformat='(A1)', $
        position=tpos, /noerase, /nodata
    oplot, xxs, yys

;---Add notations.
    min_dst = project.search_candidate.search_storm.min_dst
    max_dst = project.search_candidate.search_storm.max_dst
    foreach ty, [max_dst,min_dst] do plots, xrange, ty+[0,0], linestyle=1

    time_step = project.search_candidate.search_apogee.time_step
    common_times = make_bins(time_range, time_step)
    ncommon_time = n_elements(common_times)
    bar_thick = keyword_set(test)? 4: 8
    bar_color = sgcolor('red')
    bar_msg = 'overall'

    the_flags = get_var_data('apogee_flag', at=common_times)
    index = where(the_flags eq 1, count)
    if count ne 0 then begin
        times = common_times[index]
        time_ranges = time_to_range(times, time_step=time_step)
        ntime_range = n_elements(time_ranges)/2
        for ii=0, ntime_range-1 do plots, reform(time_ranges[ii,*]), yrange[1]+[0,0], thick=bar_thick, color=bar_color
        tx = tpos[2]+xchsz*1
        ty = tpos[3]-ychsz*label_size*half_ychsz
        xyouts, tx,ty,/normal, bar_msg, charsize=label_size, color=bar_color
    endif


;---Add axes.
    plot, xrange, yrange, $
        xstyle=1, xrange=xrange, xtickv=xtickv, xticks=xticks, xminor=xminor, xtitle=xtitle, xticklen=xticklen, xtickname=xtickn, xtickformat=xtickformat, $
        ystyle=1, yrange=yrange, ytickv=ytickv, yticks=yticks, yminor=yminor, ytitle=ytitle, yticklen=yticklen, $
        position=tpos, /noerase, /nodata

;---Add labels.
    fig_label = 'a. Dst'
    tx = 1*xchsz
    ty = tpos[3]-ychsz*constant('full_ychsz')
    xyouts, tx,ty,/normal, fig_label

    duration = total(xrange*[-1,1])/secofday
    msg = 'Storm from '+strjoin(time_string(xrange,tformat='YYYY-MM-DD/hh:mm'), ' to ')+', duration is '+sgnum2str(duration,ndec=1)+' day(s)'
    tx = tpos[0]+xchsz*0
    ty = tpos[3]+ychsz*constant('lineskip')
    xyouts, tx,ty,/normal, msg



;---Apogee MLT.
    tpos = poss[*,1]
    xticklen = xticklen_chsz*ychsz/(tpos[3]-tpos[1])
    yticklen = yticklen_chsz*xchsz/(tpos[2]-tpos[0])
    probes = project.search_candidate.search_apogee.probes
    nprobe = n_elements(probes)
    probe_colors = smkarthm(10,250,nprobe, 'n')
    probe_color_ct = 40
    foreach color, probe_colors, ii do probe_colors[ii] = sgcolor(color, ct=probe_color_ct)
    probe_labels = strarr(nprobe)
    foreach probe, probes, ii do begin
        probe_info = resolve_probe(probe)
        probe_labels[ii] = strupcase(probe_info.short_name)
    endforeach

    all_mlts = fltarr(ncommon_time,nprobe)
    foreach probe, probes, ii do all_mlts[*,ii] = get_var_data(probe+'_apogee_mlt', at=common_times)

    yrange = [-1,1]*12
    yminor = 4.
    ystep = 8.
    ytickv = smkarthm(yrange[0],yrange[1],ystep,'dx')
    yticks = n_elements(ytickv)-1
    ytitle = '(hr)'

    dy = (tpos[3]-tpos[1])/(nprobe+1)
    label_pos = smkarthm(tpos[3]-dy,-dy,nprobe, 'x0')
    label_pos -= ychsz*label_size*half_ychsz

;---Set up coord.
    plot, xrange, yrange, $
        xstyle=5, xrange=xrange, xtickformat='(A1)', $
        ystyle=5, yrange=yrange, ytickformat='(A1)', $
        position=tpos, /noerase, /nodata
    foreach probe, probes, ii do begin
        oplot, common_times, all_mlts[*,ii], color=probe_colors[ii]
        tx = tpos[2]+xchsz*1
        ty = label_pos[ii]
        xyouts, tx,ty,/normal, probe_labels[ii], color=probe_colors[ii], charsize=label_size
    endforeach

;---Add annotation.
    bar_color = sgcolor('blue')
    bar_msg = 'MLT'
    mlt_range = project.search_candidate.search_apogee.mlt_range
    foreach ty, [0,mlt_range] do plots, xrange, ty+[0,0], linestyle=1
    the_flags = get_var_data('apogee_mlt_flag', at=common_times)
    index = where(the_flags eq 1, count)
    if count ne 0 then begin
        times = common_times[index]
        time_ranges = time_to_range(times, time_step=time_step)
        ntime_range = n_elements(time_ranges)/2
        for ii=0, ntime_range-1 do plots, reform(time_ranges[ii,*]), yrange[1]+[0,0], thick=bar_thick, color=bar_color
        tx = tpos[2]+xchsz*1
        ty = tpos[3]-ychsz*label_size*half_ychsz
        xyouts, tx,ty,/normal, bar_msg, charsize=label_size, color=bar_color
    endif

;---Add axes.
    plot, xrange, yrange, $
        xstyle=1, xrange=xrange, xtickv=xtickv, xticks=xticks, xminor=xminor, xtitle=xtitle, xticklen=xticklen, xtickname=xtickn, xtickformat=xtickformat, $
        ystyle=1, yrange=yrange, ytickv=ytickv, yticks=yticks, yminor=yminor, ytitle=ytitle, yticklen=yticklen, $
        position=tpos, /noerase, /nodata

;---Add labels.
    fig_label = 'b. Apo.!C     MLT'
    tx = 1*xchsz
    ty = tpos[3]-ychsz*constant('full_ychsz')
    xyouts, tx,ty,/normal, fig_label



;---Distance.
    xtickformat = ''
    tpos = poss[*,2]
    xticklen = xticklen_chsz*ychsz/(tpos[3]-tpos[1])
    yticklen = yticklen_chsz*xchsz/(tpos[2]-tpos[0])

    all_diss = fltarr(ncommon_time,nprobe)
    foreach probe, probes, ii do all_diss[*,ii] = snorm(get_var_data(probe+'_apogee_r_gsm', at=common_times))

    yrange = [4.,15]
    yminor = 5
    ytickv = make_bins(yrange, yminor, /inner)
    yticks = n_elements(ytickv)-1
    ytitle = '(Re)'

    dy = (tpos[3]-tpos[1])/(nprobe+1)
    label_pos = smkarthm(tpos[3]-dy,-dy,nprobe, 'x0')
    label_pos -= ychsz*label_size*half_ychsz

;---Set up coord.
    plot, xrange, yrange, $
        xstyle=5, xrange=xrange, xtickformat='(A1)', $
        ystyle=5, yrange=yrange, ytickformat='(A1)', $
        position=tpos, /noerase, /nodata
    foreach probe, probes, ii do begin
        oplot, common_times, all_diss[*,ii], color=probe_colors[ii]
        tx = tpos[2]+xchsz*1
        ty = label_pos[ii]
        xyouts, tx,ty,/normal, probe_labels[ii], color=probe_colors[ii], charsize=label_size
    endforeach

;---Add annotation.
    bar_color = sgcolor('green')
    bar_msg = 'm/pause'
    the_flags = get_var_data('apogee_magn_flag', at=common_times)
    index = where(the_flags eq 1, count)
    if count ne 0 then begin
        times = common_times[index]
        time_ranges = time_to_range(times, time_step=time_step)
        ntime_range = n_elements(time_ranges)/2
        for ii=0, ntime_range-1 do plots, reform(time_ranges[ii,*]), yrange[1]+[0,0], thick=bar_thick, color=bar_color
        tx = tpos[2]+xchsz*1
        ty = tpos[3]-ychsz*label_size*half_ychsz
        xyouts, tx,ty,/normal, bar_msg, charsize=label_size, color=bar_color
    endif

;---Add axes.
    plot, xrange, yrange, $
        xstyle=1, xrange=xrange, xtickv=xtickv, xticks=xticks, xminor=xminor, xtitle=xtitle, xticklen=xticklen, xtickname=xtickn, xtickformat=xtickformat, $
        ystyle=1, yrange=yrange, ytickv=ytickv, yticks=yticks, yminor=yminor, ytitle=ytitle, yticklen=yticklen, $
        position=tpos, /noerase, /nodata

;---Add labels.
    fig_label = 'b. Apo.R'
    tx = 1*xchsz
    ty = tpos[3]-ychsz*constant('full_ychsz')
    xyouts, tx,ty,/normal, fig_label


    if keyword_set(test) then stop
    sgclose

end


pro azim_df_search_candidate_search_apogee, project=project
    ; Internal, do not check input.
    ; Search storms that have preferable apogee locations.

    if project.done_search_candidate_search_apogee then return
    lprmsg, 'Search candidate, search apogee ...'
    overall_setting = project.search_candidate
    the_key = 'search_apogee'
    if ~overall_setting.haskey(the_key) then overall_setting[the_key] = dictionary()
    settings = overall_setting[the_key]
    mlt_limit = 7.
    default_settings = dictionary($
        'probes', ['rbsp'+letters('b'),'th'+['a','d','e']], $
        'mlt_limit', mlt_limit, $
        'mlt_range', [-1,1]*mlt_limit, $
        'time_step', project.triad_time_step, $
        'time_range', overall_setting.search_storm.time_range, $
        'min_duration_ratio', 0.8, $    ; longer than ratio*storm_duration.
        'data_suffix', 'azim_df_search_candidate_search_apogee.tplot', $
        'file_suffix', 'azim_df_search_candidate_search_apogee.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]

    probes = settings.probes
    probe_info = dictionary()
    foreach probe, probes do probe_info[probe] = resolve_probe(probe)

    overall_time_range = settings.time_range
    common_times = make_bins(overall_time_range, settings.time_step)

;---Load data.
    data_file = join_path([project.data_dir,settings.data_suffix])
    if file_test(data_file) then begin
        tplot_restore, filename=data_file
    endif else begin
        save_vars = []
        foreach probe, probes do begin
            the_info = probe_info[probe]
            prefix = the_info.prefix

            ; Read orbit.
            r_var = prefix+'r_gsm'
            if ~check_if_update(r_var, overall_time_range) then continue
            call_procedure, the_info.routine_name+'_read_orbit', overall_time_range, probe=the_info.probe

            ; Find apogee, calc mlt.
            find_apogee, r_var, apogee_times=times
            rgsm = get_var_data(r_var, at=times)
            rmag = cotran(rgsm, times, 'gsm2mag')
            mlon = atan(rmag[*,1], rmag[*,0])*constant('deg')
            mlt = mlon2mlt(mlon, times)

            ; Interpolate to common_times.
            rgsm = sinterpol(rgsm, times, common_times)
            the_var = prefix+'apogee_r_gsm'
            store_data, the_var, common_times, rgsm
            add_setting, the_var, /smart, {$
                display_type: 'vector', $
                unit: 'Re', $
                short_name: 'R', $
                coord: 'GSM', $
                coord_labels: constant('xyz')}
            save_vars = [save_vars, the_var]

            the_var = prefix+'apogee_mlt'
            mlt = sinterpol(mlt, times, common_times)
            store_data, prefix+'apogee_mlt', common_times, mlt
            add_setting, the_var, /smart, {$
                display_type: 'scalar', $
                unit: 'hr', $
                short_name: 'MLT'}
            save_vars = [save_vars, the_var]
        endforeach
        tplot_save, save_vars, filename=data_file
    endelse


;---Search apogee, all_probes on one side of midnight and within magnetopause.
    nprobe = n_elements(probes)
    ncommon_time = n_elements(common_times)
    all_mlts = fltarr(ncommon_time, nprobe)
    foreach probe, probes, ii do all_mlts[*,ii] = get_var_data(probe+'_apogee_mlt')

    ; Flags for in magnetopause, 0: out of.
    all_magn_flags = bytarr(ncommon_time)+1
    foreach probe, probes do begin
        rgsm = get_var_data(probe+'_apogee_r_gsm')
        flags = check_if_in_magn(rgsm)
        index = where(flags eq 0, count)
        if count ne 0 then all_magn_flags[index] = 0
    endforeach
    store_data, 'apogee_magn_flag', common_times, all_magn_flags

    ; Flags for in pre_midnght, 1: in the region.
    all_pre_midn_flags = bytarr(ncommon_time)
    mlt_range = settings.mlt_range<0
    foreach probe, probes do begin
        mlt = get_var_data(probe+'_apogee_mlt')
        index = where_pro(mlt, '[]', mlt_range, count=count)
        if count ne 0 then all_pre_midn_flags[index] += 1
    endforeach
    ; Flags for in post_midnght, 1: in the region.
    all_post_midn_flags = bytarr(ncommon_time)
    mlt_range = settings.mlt_range>0
    foreach probe, probes do begin
        mlt = get_var_data(probe+'_apogee_mlt')
        index = where_pro(mlt, '[]', mlt_range, count=count)
        if count ne 0 then all_post_midn_flags[index] += 1
    endforeach

    ; Overall flag, 1: in magnetopause and on one side of midnight.
    all_mlt_flags = (all_pre_midn_flags eq nprobe) or (all_post_midn_flags eq nprobe)
    all_flags = (all_magn_flags eq 1) and (all_mlt_flags eq 1)
    store_data, 'apogee_mlt_flag', common_times, all_mlt_flags
    store_data, 'apogee_flag', common_times, all_flags
    vars = 'apogee_'+[['magn','mlt']+'_','']+'flag'
    options, vars, 'yrange', [-0.1,1.1]

    the_var = 'apogee_mlt_count'
    store_data, the_var, common_times, [[all_pre_midn_flags],[all_post_midn_flags]]
    add_setting, the_var, {$
        ytitle: '#', $
        labels: strupcase(['pre','post']), $
        colors: sgcolor(['red','blue'])}


    storm_times = overall_setting.search_storm.storm_times
    nstorm = n_elements(storm_times)/2
    storm_flags = bytarr(nstorm)+1
    mlt_range = settings.mlt_range
    for ii=0, nstorm-1 do begin
        time_range = reform(storm_times[ii,*])
        index = where_pro(common_times, '[]', time_range, count=ntime)
        the_flags = all_flags[index]
        index = where(the_flags eq 1, count)
        if count eq 0 then storm_flags[ii] = 0
        storm_duration = total(time_range*[-1,1])
        min_duration = storm_duration*settings.min_duration_ratio
        duration = n_elements(index)*settings.time_step
        if duration lt min_duration then storm_flags[ii] = 0
    endfor

    index = where(storm_flags eq 1, nselected_storm)
    if nselected_storm eq 0 then message, 'No selected storm, stop here ...'
    selected_storms = storm_times[index,*]


;---Save results, save diagnostic plots.
    lprmsg, 'Save diagnostic plots ...'
    for ii=0, nselected_storm-1 do begin
        time_range = reform(selected_storms[ii,*])
        lprmsg, 'Processing storm from '+strjoin(time_string(time_range)+' to ')+' ...'
        plot_file = join_path([project.plot_dir,'diagnostic_plot','search_candidate','search_apogee','storm_'+strjoin(time_string(time_range,tformat='YYYY_MMDD_hh'),'_')+'.pdf'])
        azim_df_search_candidate_search_apogee_diagnostic_plot, project=project, time_range=time_range, file=plot_file
    endfor

    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    for ii=0, nselected_storm-1 do printf, lun, strjoin(time_string(reform(selected_storms[ii,*]),tformat='YYYY-MM-DD/hh:mm'),' ')
    free_lun, lun

    lprmsg, 'Update project ...'
    settings.storm_times = selected_storms
    project.done_search_candidate_search_apogee = 1
    update_project, project

end




pro azim_df_search_candidate_search_triad_diagnostic_plot, project=project, info=info, file=plot_file
    ; Internal.
test = 0


;---Figure out the size of the plot.
    margins = [8.,5,2,1]
    pans = [1]
    nypanel = n_elements(pans)
    panel_ypad = 0.5
    panel_ysize = 4
    panel_xsize = panel_ysize
    sgopen, 0, xsize=1, ysize=1, /inch, xchsz=abs_xchsz,ychsz=abs_ychsz
    sgclose, /wdelete
    fig_xsize = panel_xsize+total(margins[[0,2]])*abs_xchsz
    fig_ysize = panel_ysize+total(margins[[1,3]])*abs_ychsz+panel_ypad*(nypanel-1)

    if n_elements(plot_file) eq 0 then plot_file = 0
    if keyword_set(test) then plot_file = test
    sgopen, plot_file, xsize=fig_xsize, ysize=fig_ysize, /inch, xchsz=xchsz, ychsz=ychsz
    pos = margins*[abs_xchsz,abs_ychsz,abs_xchsz,abs_ychsz]/[fig_xsize,fig_ysize,fig_xsize,fig_ysize]
    pos = [pos[0:1],1-pos[2:3]]

    probes = info.available_probes
    all_probes = tnames('*_r_sm')
    foreach probe, all_probes, ii do all_probes[ii] = strmid(probe,0,strpos(probe,'_'))
    nall_probe = n_elements(all_probes)
    all_probe_colors = smkarthm(10,250,nall_probe, 'n')
    probe_color_ct = 40
    foreach color, all_probe_colors, ii do all_probe_colors[ii] = sgcolor(color, ct=probe_color_ct)


;---X-Y plane.
    tpos = pos
    ticklen = -0.01

    time_range = info.time_range
    probes = info.available_probes
    region = info.region

    xrange = [20.,-40]
    xstep = 20
    xtickv = make_bins(xrange, xstep)
    xticks = n_elements(xtickv)-1
    xminor = 5
    xtitle = 'SM X (Re)'
    xticklen = ticklen

    yrange = (region eq 'pre_midn')? [40.,-20]: [20.,-40]
    ystep = 20
    ytickv = make_bins(yrange, ystep)
    yticks = n_elements(ytickv)-1
    yminor = 5
    ytitle = 'SM Y (Re)'
    yticklen = ticklen

    bar_thick = keyword_set(test)? 1: 4
    full_ychsz = constant('full_ychsz')
    label_size = constant('label_size')
    lineskip = constant('lineskip')

;---Set up coord.
    plot, xrange, yrange, $
        xstyle=5, xrange=xrange, xtickformat='(A1)', $
        ystyle=5, yrange=yrange, ytickformat='(A1)', $
        position=tpos, /noerase, /nodata, /iso

    ; Add earth.
    tmp = smkarthm(0,1,50,'n')*2*!dpi
    circle_x = cos(tmp)
    circle_y = sin(tmp)
    polyfill, circle_x<0, circle_y, color=sgcolor('silver')
    plots, circle_x, circle_y

    ; Add more circles.
    foreach tmp, [5,10,20,40] do oplot, circle_x*tmp, circle_y*tmp, linestyle=1

    ; Add mlt_range.
    rad = constant('rad')
    foreach tmp, [0,-9,9] do oplot, [0,-40]*cos(tmp*15*rad), [0,-40]*sin(tmp*15*rad), linestyle=1


;---Add axes.
    plot, xrange, yrange, $
        xstyle=1, xrange=xrange, xtickv=xtickv, xticks=xticks, xminor=xminor, xtitle=xtitle, xticklen=xticklen, xtickname=xtickn, xtickformat=xtickformat, $
        ystyle=1, yrange=yrange, ytickv=ytickv, yticks=yticks, yminor=yminor, ytitle=ytitle, yticklen=yticklen, $
        position=tpos, /noerase, /nodata

    foreach probe, all_probes, ii do begin
        prefix = probe+'_'
        rsm = get_var_data(prefix+'r_sm', in=time_range)
        xxs = rsm[*,0]
        yys = rsm[*,1]
        index = where(probes eq probe, count)
        thick = (count eq 0)? 0.5*bar_thick: 2*bar_thick
        plots, xxs, yys, color=all_probe_colors[ii], thick=thick
    endforeach

    ty0 = (region eq 'pre_midn')? tpos[3]: tpos[1]+ychsz*full_ychsz*(3+lineskip)
    tx = tpos[0]+xchsz*1
    step = 4

    ty = ty0-ychsz*full_ychsz*1
    xyouts, tx,ty,/normal, 'Probes form triads: ', charsize=label_size
    ttx = tx+15*xchsz*label_size
    foreach probe, all_probes, ii do begin
        index = where(probes eq probe, count)
        if count eq 0 then continue
        probe_info = resolve_probe(probe)
        xyouts, ttx,ty,/normal, strupcase(probe_info.short_name), color=all_probe_colors[ii], charsize=label_size
        ttx += step*xchsz*label_size
    endforeach

    ty = ty0-ychsz*full_ychsz*2
    xyouts, tx,ty,/normal, 'All available probes: ', charsize=label_size
    ttx = tx+15*xchsz*label_size
    foreach probe, all_probes, ii do begin
        probe_info = resolve_probe(probe)
        xyouts, ttx,ty,/normal, strupcase(probe_info.short_name), color=all_probe_colors[ii], charsize=label_size
        ttx += step*xchsz*label_size
    endforeach

    ty = ty0-ychsz*full_ychsz*3
    duration = total(time_range*[-1,1])/constant('secofhour')
    msg = 'Orbit from '+strjoin(time_string(time_range,tformat='YYYY-MM-DD/hh:mm'), ' to ')+', duration is '+sgnum2str(duration,ndec=1)+' hour(s)'
    xyouts, tx,ty,/normal, msg, charsize=label_size

;---Add labels.
    fig_label = 'a. XY!C    plane'
    tx = 1*xchsz
    ty = tpos[3]-ychsz*full_ychsz
    xyouts, tx,ty,/normal, fig_label



    if keyword_set(test) then stop
    sgclose




end

pro azim_df_search_candidate_search_triad, project=project
    ; Internal, do not check input.
    ; Search times when there are enough good triads.

    if project.done_search_candidate_search_triad then return
    lprmsg, 'Search candidate, search triad ...'
    overall_setting = project.search_candidate
    the_key = 'search_triad'
    if ~overall_setting.haskey(the_key) then overall_setting[the_key] = dictionary()
    settings = overall_setting[the_key]
    small_angle_limit = 15. ; deg.
    mlt_limit = 9.  ; hr.
    mlt_range = [-1,1]*mlt_limit
    dis_range = [4.,40] ; Re.
    regions = dictionary($
        'post_midn', dictionary('mlt_range', [0, mlt_limit], 'dis_range', dis_range), $
        'pre_midn',  dictionary('mlt_range', [-mlt_limit,0], 'dis_range', dis_range))
    default_settings = dictionary($
        'regions', regions, $
        'probes', ['rbsp'+letters('b'),'th'+['a','d','e'],'mms1','g'+['13','14','15']], $
        'time_step', project.triad_time_step, $
        'small_angle_limit', small_angle_limit, $
        'angle_range', [small_angle_limit,180-small_angle_limit], $
        'mlt_range', mlt_range, $
        'dis_range', dis_range, $
        'min_triad_count', 6, $
        'min_triad_duration', 3600., $  ; sec.
        'file_suffix', 'azim_df_search_candidate_search_triad.txt')
    foreach key, default_settings.keys() do if ~settings.haskey(key) then settings[key] = default_settings[key]
    nvertex = 3     ; triangle.
    min_triad_count = settings.min_triad_count
    min_triad_duration = settings.min_triad_duration
    regions = settings.regions

    all_probes = settings.probes
    probe_info = dictionary()
    foreach probe, all_probes do probe_info[probe] = resolve_probe(probe)

    time_step = settings.time_step
    storm_times = overall_setting.search_apogee.storm_times
    nstorm = n_elements(storm_times)/2
    candidate_info = list()
    for ii=0, nstorm-1 do begin
        time_range = reform(storm_times[ii,*])

    ;test_time = time_double('2013-10-02')
    if n_elements(test_time) ne 0 then begin
        index = where_pro(test_time, '[]', time_range, count=count)
        if count eq 0 then continue
    endif

        common_times = make_bins(time_range, time_step)
        ncommon_time = n_elements(common_times)

    ;---Load orbit data and figure out the probes have data.
        available_probes = []
        del_data, '*'
        foreach probe, all_probes do begin
            prefix = probe_info[probe].prefix
            r_gsm_var = prefix+'r_gsm'
            b_gsm_var = prefix+'b_gsm'
            r_sm_var = prefix+'r_sm'
            mlt_var = prefix+'mlt'

            call_procedure, probe_info[probe].routine_name+'_read_orbit', time_range, probe=probe_info[probe].probe
            if tnames(r_gsm_var) eq '' then continue
            call_procedure, probe_info[probe].routine_name+'_read_bfield', time_range, probe=probe_info[probe].probe
            if tnames(b_gsm_var) eq '' then continue

            available_probes = [available_probes, probe]

            r_gsm = get_var_data(r_gsm_var, at=common_times)
            r_sm = cotran(r_gsm, common_times, 'gsm2sm')
            store_data, r_sm_var, common_times, r_sm
            add_setting, r_sm_var, /smart, {$
                display_type: 'vector', $
                short_name: 'R', $
                unit: 'Re', $
                coord: 'SM', $
                coord_labels: constant('xyz')}

            r_mag = cotran(r_gsm, common_times, 'gsm2mag')
            mlon = atan(r_mag[*,1],r_mag[*,0])*constant('deg')
            mlt = mlon2mlt(mlon, common_times)
            store_data, mlt_var, common_times, mlt
            add_setting, mlt_var, /smart, {$
                display_type: 'scalar', $
                unit: 'hr', $
                range: settings.mlt_range, $
                short_name: 'MLT'}
        endforeach


    ;---Flag for data within region of interest.
        navailable_probe = n_elements(available_probes)
        if navailable_probe lt nvertex then continue
        data_flags = bytarr(ncommon_time, navailable_probe)+1
        foreach probe, available_probes, jj do begin
            prefix = probe_info[probe].prefix
            r_gsm_var = prefix+'r_gsm'
            r_gsm = get_var_data(r_gsm_var, at=common_times)
            ; In magnetosphere.
            index = where(check_if_in_magn(r_gsm) eq 0, count)
            if count ne 0 then data_flags[index,jj] = 0
            ; In mlt_range.
            mlt_var = prefix+'mlt'
            index = where_pro(get_var_data(mlt_var, at=common_times), '][', settings.mlt_range, count=count)
            if count ne 0 then data_flags[index,jj] = 0
            ; In dis_range.
            index = where_pro(snorm(r_gsm), '][', settings.dis_range, count=count)
            if count ne 0 then data_flags[index,jj] = 0
            ; Have bfield.
            b_gsm_var = prefix+'b_gsm'
            index = where(finite(snorm(get_var_data(b_gsm_var, at=common_times)),/nan), count)
            if count ne 0 then data_flags[index,jj] = 0
        endforeach
        probe_labels = strarr(navailable_probe)
        foreach probe, available_probes, jj do probe_labels[jj] = strupcase(probe_info[probe].short_name)
        probe_colors = smkarthm(10,250,navailable_probe, 'n')
        probe_color_ct = 40
        foreach color, probe_colors, jj do probe_colors[jj] = sgcolor(color, ct=probe_color_ct)
        store_data, 'data_flag', common_times, data_flags, limits={$
            ytitle: '(#)', labels: probe_labels, colors: probe_colors, yrange: [-0.1,1.1], labflag: -1}

        foreach probe, available_probes do begin
            prefix = probe_info[probe].prefix
            r_sm = get_var_data(prefix+'r_sm', at=common_times)
            store_data, prefix+'x_sm', common_times, r_sm[*,0]
            store_data, prefix+'y_sm', common_times, r_sm[*,1]
        endforeach


    ;---Search in each region.
        foreach region, regions.keys() do begin
            mlt_flags = bytarr(ncommon_time, navailable_probe)+1
            mlt_range = regions[region].mlt_range
            foreach probe, available_probes, jj do begin
                prefix = probe_info[probe].prefix
                index = where_pro(get_var_data(prefix+'mlt', at=common_times), '][', mlt_range, count=count)
                if count ne 0 then mlt_flags[index,jj] = 0
            endforeach
            region_mlt_flag_var = region+'_mlt_flag'
            store_data, region_mlt_flag_var, common_times, mlt_flags, limits={$
                ytitle: '(#)', labels: probe_labels, colors: probe_colors, yrange: [-0.1,1.1], labflag: -1}

            triad_counts = intarr(ncommon_time)
            triad_probes = bytarr(ncommon_time,navailable_probe)
            foreach time, common_times, jj do begin
                if n_elements(test_time) ne 0 then if time eq test_time then stop
                index = where((data_flags[jj,*] and mlt_flags[jj,*]) eq 1, count)
                if count le nvertex then continue
                triad_probes[jj,index] = 1
                triads = choose_from(available_probes[index], nvertex)
                ntriad = n_elements(triads)
                the_count = intarr(ntriad)
                xxs = fltarr(nvertex)
                yys = fltarr(nvertex)
                angles = fltarr(nvertex)
                foreach triad, triads, kk do begin
                    for mm=0,nvertex-1 do xxs[mm] = get_var_data(triad[mm]+'_x_sm', at=time)
                    for mm=0,nvertex-1 do yys[mm] = get_var_data(triad[mm]+'_y_sm', at=time)
                    for mm=0,nvertex-1 do begin
                        xxs = shift(xxs,1)
                        yys = shift(yys,1)
                        angles[mm] = sang($
                            [xxs[1]-xxs[0],yys[1]-yys[0]], $
                            [xxs[2]-xxs[0],yys[2]-yys[0]], /degree)
                    endfor
                    index = where_pro(angles, '[]', settings.angle_range, count=count)
                    if count eq nvertex then the_count[kk] = 1 ; A good triad.
                endforeach
                triad_counts[jj] = total(the_count)
            endforeach

            region_triad_count_var = region+'_triad_count'
            store_data, region_triad_count_var, common_times, triad_counts, limits={$
                ytitle: '(#)', labels: region, constant: min_triad_count}
            region_triad_probe_var = region+'_triad_probe'
            store_data, region_triad_probe_var, common_times, triad_probes, limits={$
                ytitle: '(#)', labels: region}
        endforeach


    ;---Select periods when there are enough good triads.
        foreach region, regions.keys() do begin
            triad_counts = get_var_data(region+'_triad_count')
            index = where(triad_counts ge min_triad_count, count)
            if count eq 0 then continue
            times = common_times[index]
            time_ranges = time_to_range(times, time_step=time_step)
            durations = time_ranges[*,1]-time_ranges[*,0]
            index = where(durations ge min_triad_duration, count)
            if count eq 0 then continue
            time_ranges = time_ranges[index,*]

            ntime_range = n_elements(time_ranges)/2
            for jj=0, ntime_range-1 do begin
                the_time_range = reform(time_ranges[jj,*])
                triad_probe_counts = total(get_var_data(region+'_triad_probe', in=the_time_range),1)
                min_count = total(the_time_range*[-1,1])/time_step*0.5
                index = where(triad_probe_counts gt min_count, count)
                if count eq 0 then message, 'Inconsistency: no triad but should have some ...'
                triad_probes = available_probes[index]
                info = dictionary($
                    'time_range', the_time_range, $
                    'available_probes', triad_probes, $
                    'region', region)
                candidate_info.add, info

            ;---Save diagnostic plot.
                lprmsg, 'Save diagnostic plots ...'
                plot_file = join_path([project.plot_dir,'diagnostic_plot','search_candidate','search_triad','candidate_'+time_string(info.time_range[0],tformat='YYYY_MMDD_hh')+'.pdf'])
                azim_df_search_candidate_search_triad_diagnostic_plot, project=project, info=info, file=plot_file
            endfor
        endforeach


    endfor


;---Save results.
    file_suffix = settings.file_suffix
    file = join_path([project.data_dir,file_suffix])
    lprmsg, 'Write results to '+file+' ...'
    openw, lun, file, /get_lun
    foreach info, candidate_info do begin
        msg = [$
            time_string(info.time_range,tformat='YYYY-MM-DD/hh:mm'), $
            info.region, strjoin(info.available_probes,',')]
        msg = strjoin(msg, ' ')
        printf, lun, msg
    endforeach
    free_lun, lun

    lprmsg, 'Update project ...'
    settings.candidates = candidate_info
    project.done_search_candidate_search_triad = 1
    update_project, project


end


pro azim_df_search_candidate, project=project, reset=reset

    if n_elements(project) eq 0 then project = azim_df_load_project()

    keys = 'done_search_candidate'+['_search_storm','_search_apogee','_search_triad','']
    foreach the_key, keys do begin
        if ~project.haskey(the_key) then project[the_key] = 0
        if keyword_set(reset) then project[the_key] = 0
    endforeach

    the_key = 'search_candidate'
    if ~project.haskey(the_key) then project[the_key] = dictionary()


    if project.done_search_candidate then begin
        return
    endif else begin
        azim_df_search_candidate_search_storm, project=project
        azim_df_search_candidate_search_apogee, project=project
        azim_df_search_candidate_search_triad, project=project
        azim_df_search_candidate_save, project=project
        project.done_search_candidate = 1
        update_project, project
    endelse

end
